%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{5}
\setcounter{secnumdepth}{5}


\title{data\_tools Documentation}
\date{Jun 05, 2019}
\release{0.0.7}
\author{Nicolàs Palacio-Escat}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


Data tools: a collection of Python functions and classes designed to
make data scientists’ life easier.

Copyright (C) 2019 Nicolàs Palacio-Escat

Contact: \sphinxhref{mailto:nicolas.palacio@bioquant.uni-heidelberg.de}{nicolas.palacio@bioquant.uni-heidelberg.de}


\chapter{Disclaimer}
\label{\detokenize{index:disclaimer}}
This package is still under development and will be periodically updated
with new features. Contributions are very welcome (fork + pull request).
If you find any bug or suggestion for upgrades, please use the
\sphinxhref{https://github.com/Nic-Nic/data\_tools/issues}{issue system}.

GNU-GLPv3:
This program is free software: you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
Public License for more details.

A full copy of the GNU General Public License can be found on file
\sphinxhref{https://github.com/Nic-Nic/data\_tools/blob/master/LICENSE.md}{LICENSE.md}.
If not, see \sphinxurl{http://www.gnu.org/licenses/}.


\chapter{Dependencies}
\label{\detokenize{index:dependencies}}\begin{itemize}
\item {} 
\sphinxhref{http://www.numpy.org/}{NumPy}

\item {} 
\sphinxhref{https://matplotlib.org/}{Matplotlib}

\item {} 
\sphinxhref{https://pandas.pydata.org/}{Pandas}

\item {} 
\sphinxhref{https://www.scipy.org/}{SciPy}

\item {} 
\sphinxhref{http://scikit-learn.org/stable/index.html}{Scikit-learn}

\item {} 
\sphinxhref{https://upsetplot.readthedocs.io/en/stable/}{UpSetPlot}

\end{itemize}


\chapter{Installation}
\label{\detokenize{index:installation}}
First download/clone \sphinxcode{\sphinxupquote{data\_tools}} from the
\sphinxhref{https://github.com/Nic-Nic/data\_tools.git}{GitHub repository}.
From the terminal:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
git clone https://github.com/Nic\PYGZhy{}Nic/data\PYGZus{}tools.git
\PYG{n+nb}{cd} data\PYGZus{}tools
\end{sphinxVerbatim}

Then you can install it by running \sphinxcode{\sphinxupquote{setup.py}} as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
python setup.py sdist
\end{sphinxVerbatim}

Or using \sphinxcode{\sphinxupquote{pip}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
pip install .
\end{sphinxVerbatim}

Along with \sphinxcode{\sphinxupquote{data\_tools}}, all dependencies will be installed as well as
the testing suite. In order to run the tests, type on the terminal:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
python \PYGZhy{}m test\PYGZus{}data\PYGZus{}tools
\end{sphinxVerbatim}

\sphinxstylestrong{NOTE:} \sphinxcode{\sphinxupquote{data\_tools.plots}} module does not have any tests
implemented.


\chapter{Module reference}
\label{\detokenize{index:module-reference}}\phantomsection\label{\detokenize{databases:module-data_tools.databases}}\index{data\_tools.databases (module)@\spxentry{data\_tools.databases}\spxextra{module}}

\section{data\_tools.databases}
\label{\detokenize{databases:data-tools-databases}}\label{\detokenize{databases::doc}}
Databases functions module.


\subsection{Contents}
\label{\detokenize{databases:contents}}\index{kegg\_link() (in module data\_tools.databases)@\spxentry{kegg\_link()}\spxextra{in module data\_tools.databases}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{databases:data_tools.databases.kegg_link}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{data\_tools.databases.}}\sphinxbfcode{\sphinxupquote{kegg\_link}}}{\emph{query}, \emph{target='pathway'}}{}
Queries a request to the KEGG database to find related entries using
cross-references. A list of available database(s) and query examples
can be found in \sphinxurl{https://www.kegg.jp/kegg/rest/keggapi.html\#link}.
\begin{itemize}
\item {} \begin{description}
\item[{Arguments:}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{query} {[}list{]}: Or any iterable type containing the
identifier(s) to be queried as {[}str{]}. These can be either
valid database identifiers or databases \sphinxstyleemphasis{per se} (see the link
above).

\item {} 
\sphinxstyleemphasis{target} {[}str{]}: Optional, \sphinxcode{\sphinxupquote{'pathway'}} by default. Targeted
database to which the query should be linked to. You can check
other options available in the URL above.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Returns:}] \leavevmode\begin{itemize}
\item {} 
{[}pandas.DataFrame{]}: Two-column table containing both the
input query identifiers and their linked ones.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Example:}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{my\PYGZus{}query} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{hsa:10458}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ece:Z5100}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{kegg\PYGZus{}link}\PYG{p}{(}\PYG{n}{my\PYGZus{}query}\PYG{p}{)}
\PYG{g+go}{   query        pathway}
\PYG{g+go}{0  hsa:10458  path:hsa04520}
\PYG{g+go}{1  hsa:10458  path:hsa04810}
\PYG{g+go}{2  ece:Z5100  path:ece05130}
\end{sphinxVerbatim}

\end{description}

\end{itemize}

\end{fulllineitems}

\index{kegg\_pathway\_mapping() (in module data\_tools.databases)@\spxentry{kegg\_pathway\_mapping()}\spxextra{in module data\_tools.databases}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{databases:data_tools.databases.kegg_pathway_mapping}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{data\_tools.databases.}}\sphinxbfcode{\sphinxupquote{kegg\_pathway\_mapping}}}{\emph{df}, \emph{mapid}, \emph{filename=None}}{}
Makes a request to KEGG pathway mapping tool according to a given
pathway ID (see \sphinxurl{https://www.kegg.jp/kegg/tool/map\_pathway2.html} for
more information). The user must provide a query of IDs to be mapped
with their corresponding background colors (and optionally also
foreground colors). The result is downloaded in the current
directory or a user-specified path.
\begin{itemize}
\item {} \begin{description}
\item[{Arguments:}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{df} {[}pandas.DataFrame{]}: Dataframe containing KEGG valid IDs
in the first column and corresponding background colors (e.g.:
red, blue, …). Optionally, a third column with the
foreground (font) colors can also be provided (black by
default). \sphinxstylestrong{NOTE:} hexadecimal codes for colors is also
supported. Index and column names of dataframe are ignored.

\item {} 
\sphinxstyleemphasis{mapid} {[}str{]}: A valid KEGG pathway ID. It can be a general
(e.g.: “mapXXXXX”) or organism-specific ID (e.g.: “hsaXXXXX”).

\item {} 
\sphinxstyleemphasis{filename} {[}str{]}: Optional, \sphinxcode{\sphinxupquote{None}} by default. This is, the
image will be stored in the current directory with the \sphinxstyleemphasis{mapid}
provided as file name. If provided, the image will be stored
within the specified path/file name.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Example:}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{my\PYGZus{}query} \PYG{o}{=} \PYG{n}{pandas}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1956}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{red}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsh{}f1f1f1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}
\PYG{g+gp}{... }                             \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{3845}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{blue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsh{}f1f1f1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}
\PYG{g+gp}{... }                             \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{5594}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{green}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{black}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{kegg\PYGZus{}pathway\PYGZus{}mapping}\PYG{p}{(}\PYG{n}{my\PYGZus{}query}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{hsa04010}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent{\hspace*{\fill}\sphinxincludegraphics{{hsa04010}.png}\hspace*{\fill}}

\end{description}

\end{itemize}

\end{fulllineitems}

\index{op\_kinase\_substrate() (in module data\_tools.databases)@\spxentry{op\_kinase\_substrate()}\spxextra{in module data\_tools.databases}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{databases:data_tools.databases.op_kinase_substrate}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{data\_tools.databases.}}\sphinxbfcode{\sphinxupquote{op\_kinase\_substrate}}}{\emph{organism='9606'}, \emph{incl\_phosphatases=False}}{}
Queries OmniPath to retrieve the kinase-substrate interactions for a
given organism.
\begin{itemize}
\item {} \begin{description}
\item[{Arguments:}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{organism} {[}str{]}: Optional, \sphinxcode{\sphinxupquote{'9606'}} by default (Homo
sapiens). NCBI taxonomic identifier for the organism of
interest.

\item {} 
\sphinxstyleemphasis{incl\_phosphatases} {[}bool{]}: Optional \sphinxcode{\sphinxupquote{False}} by default.
Determines wether to include dephosphorylation interactions or
not.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Returns:}] \leavevmode\begin{itemize}
\item {} 
{[}pandas.DataFrame{]}: Table containing the enzyme-substrate
(kinase/phosphatase-target) network of each phospho-site.

\end{itemize}

\end{description}

\end{itemize}

\end{fulllineitems}

\index{up\_map() (in module data\_tools.databases)@\spxentry{up\_map()}\spxextra{in module data\_tools.databases}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{databases:data_tools.databases.up_map}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{data\_tools.databases.}}\sphinxbfcode{\sphinxupquote{up\_map}}}{\emph{query}, \emph{source='ACC'}, \emph{target='GENENAME'}}{}
Queries a request to UniProt.org in order to map a given list of
identifiers. You can check the options available of input/output
identifiers at \sphinxurl{https://www.uniprot.org/help/api\_idmapping}.
\begin{itemize}
\item {} \begin{description}
\item[{Arguments:}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{query} {[}list{]}: Or any iterable type containing the
identifiers to be queried as {[}str{]}.

\item {} 
\sphinxstyleemphasis{source} {[}str{]}: Optional, \sphinxcode{\sphinxupquote{'ACC'}} by default. This is,
UniProt accesion number. You can check other options available
in the URL above.

\item {} 
\sphinxstyleemphasis{target} {[}str{]}: Optional, \sphinxcode{\sphinxupquote{'GENENAME'}} by default. You can
check other options available in the URL above.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Returns:}] \leavevmode\begin{itemize}
\item {} 
{[}pandas.DataFrame{]}: Two-column table containing both the
inputed identifiers and the mapping result of these. \sphinxstylestrong{NOTE:}
The returned table may not have the same order as in
\sphinxcode{\sphinxupquote{query}}. Also, if some ID could not be mapped, the size of
the returned table will differ from the length of \sphinxcode{\sphinxupquote{query}}.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Examples:}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{my\PYGZus{}query} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{P00533}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{P31749}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{P16220}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{up\PYGZus{}map}\PYG{p}{(}\PYG{n}{my\PYGZus{}query}\PYG{p}{)}
\PYG{g+go}{      ACC GENENAME}
\PYG{g+go}{0  P00533     EGFR}
\PYG{g+go}{1  P31749     AKT1}
\PYG{g+go}{2  P16220    CREB1}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{up\PYGZus{}map}\PYG{p}{(}\PYG{n}{my\PYGZus{}query}\PYG{p}{,} \PYG{n}{target}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{KEGG\PYGZus{}ID}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{      ACC   KEGG\PYGZus{}ID}
\PYG{g+go}{0  P00533  hsa:1956}
\PYG{g+go}{2  P16220  hsa:1385}
\PYG{g+go}{1  P31749   hsa:207}
\end{sphinxVerbatim}

\end{description}

\end{itemize}

\end{fulllineitems}

\phantomsection\label{\detokenize{diffusion:module-data_tools.diffusion}}\index{data\_tools.diffusion (module)@\spxentry{data\_tools.diffusion}\spxextra{module}}

\section{data\_tools.diffusion}
\label{\detokenize{diffusion:data-tools-diffusion}}\label{\detokenize{diffusion::doc}}
Diffusion solvers module.


\subsection{Introduction}
\label{\detokenize{diffusion:introduction}}
The following functions provide tools to solve the diffusion problem for
any number of spatial dimensions with different explicit and implicit
methods. The problem is defined as follows:
\begin{equation*}
\begin{split}\frac{\partial u}{\partial t} = D\nabla^2u\end{split}
\end{equation*}
Where \(u\) is the diffusing component, \(D\) is the diffusion
coefficient and \(\nabla^2\) is the Laplace operator
(in Euclidean space \(\nabla^2f=\nabla\cdot\nabla f=\sum_{i=1}^n\frac{\partial^2 f}{\partial x_i^2}\)).

Some numerical methods to solve this probelm will be explained in
the following subsections. These are based in approximation of the
derivatives by finite-differences. Therefore we define the
discretization step sizes as \(\Delta t\) for the time derivative
and \(\Delta x\), \(\Delta y\) and so on for first, second and
subsequent spatial dimensions respectively.

From here on we will assume that space is homogeneously discretized
(e.g.: \(\Delta x=\Delta y\)). All second-order partial
derivatives in the spatial dimension are discretized using central
finite differences. For instance, in one dimension:
\begin{equation*}
\begin{split}\frac{\partial^2u}{\partial x^2}\approx\frac{u_{i-1}-2u_i+u_{i+1  }}{\Delta x^2}\end{split}
\end{equation*}

\subsubsection{Euler explicit method}
\label{\detokenize{diffusion:euler-explicit-method}}
“Classic” method, first-order accurate, uses forward difference over
time:
\begin{equation*}
\begin{split}\frac{\partial u}{\partial t}\approx\frac{u^{k+1}-u^k}{\Delta t}\end{split}
\end{equation*}
Where \(k\) is the current time-step. Applied to the diffusion
problem for one dimension and rearranging terms:
\begin{equation*}
\begin{split}u_i^{k+1}=\frac{D\Delta t}{\Delta x^2}\left(u_{i+1}^k+u_{i-1}^k  \right)+\left(1-2\frac{D\Delta t}{\Delta x^2}\right)u_i^k\end{split}
\end{equation*}
Let us define from here on \(\lambda\equiv\frac{D\Delta t}{\Delta x^2}\) for simplicity. Rewriting the equation above in terms of
linear algebra, each time-step the next state of \(u\) is:
\begin{equation*}
\begin{split}u^{k+1}=\mathbf{A}u^{k}\end{split}
\end{equation*}
Where \(\mathbf{A}\) is the tri-diagonal coefficient matrix whose
central element is \((1-2\lambda)\) and its adjacent diagonals are
\(\lambda\). Note that for \(n\)-dimensional case, central
element will then be \((1-2n\lambda)\) and \(u\) must be
flattened (coerced into one dimension) and \(\mathbf{A}\) becomes
a block tri-diagonal matrix.

\sphinxstylestrong{NOTE:} Explicit methods are conditionally stable. This means that in
order to keep numerical stability of the solution (and obtain an
accurate result), these methods need to fulfill the
Courant\textendash{}Friedrichs\textendash{}Lewy (CFL) condition. For any \(n\)-dimensional
case:
\begin{equation*}
\begin{split}D\frac{\Delta t}{\Delta x^2}\leq\frac{1}{2n}\end{split}
\end{equation*}
The implicit methods are (theoretically) unconditionally stable, hence
are more permissive in terms of discretization step-size.


\subsubsection{Euler implicit method}
\label{\detokenize{diffusion:euler-implicit-method}}
Similar to Euler explicit (first-order accurate) but uses backward
difference over time:
\begin{equation*}
\begin{split}\frac{\partial u}{\partial t}\approx\frac{u^k-u^{k-1}}{\Delta t}\end{split}
\end{equation*}
Applied to the diffusion problem in one dimension and taking one step
forward over discrete time (\(k\rightarrow k+1\)):
\begin{equation*}
\begin{split}u_i^k=-\lambda\left(u_{i+1}^{k+1}+u_{i-1}^{k+1}\right)+\left(1+2  \lambda\right)u_i^{k+1}\end{split}
\end{equation*}
Posed as a linear algebra problem:
\begin{equation*}
\begin{split}u^{k}=\mathbf{A}u^{k+1}\end{split}
\end{equation*}
Where \(\mathbf{A}\) is the tri-diagonal coefficient matrix whose
central element is \((1+2\lambda)\) and its adjacent diagonals are
\(-\lambda\). For \(n\)-dimensional case, central element will
then be \((1+2n\lambda)\) and \(u\) must be flattened (coerced
into one dimension) and \(\mathbf{A}\) becomes a block tri-diagonal
matrix.


\subsubsection{Crank-Nicolson method}
\label{\detokenize{diffusion:crank-nicolson-method}}
Implicit method, second-order accurate that uses trapezoidal rule for
integration time between forward and backward differences. Therefore,
assuming \(u_t=f(u,t)\) then:
\begin{equation*}
\begin{split}\frac{u^{k+1}-u^k}{\Delta t}=\frac{1}{2}\left(f(u^k,t^k)+f(u^{k+1  },t^{k+1})\right)\end{split}
\end{equation*}
Applied to the diffusion problem in one dimension:
\begin{equation*}
\begin{split}\frac{\lambda}{2}\left(u_{i+1}^k+u_{i-1}^k\right)+\left(1-  \lambda\right)u_i^k=-\frac{\lambda}{2}\left(u_{i+1}^{k+1}+  u_{i-1}^{k+1}\right)+\left(1+\lambda\right)u_i^{k+1}\end{split}
\end{equation*}
Posed as a linear algebra problem:
\begin{equation*}
\begin{split}\mathbf{A}u^{k+1}=\mathbf{B}u^k\end{split}
\end{equation*}
Where \(\mathbf{A}\) is the tri-diagonal coefficient matrix for
\(k+1\) whose central element is \((1+\lambda)\) and its
adjacent diagonals are \(-\frac{\lambda}{2}\). Similarly,
:mathbf\{B\}: is the tri-diagonal matrix for \(k\) whose central
element is \((1-\lambda)\) and its adjacent diagonals are
\(\frac{\lambda}{2}\). For \(n\)-dimensional case, central
elements will then be \((1+n\lambda)\) and \((1-n\lambda)\)
for \(\mathbf{A}\) and \(\mathbf{B}\) respectively and
\(u\) must be flattened (coerced into one dimension) as well as that
coefficient matrices become block tri-diagonal matrices.


\bigskip\hrule\bigskip


Independently of the numerical method, it is assumed that the problem is
posed in terms of linear algebra. This is, the current and next state
of the diffusing field \(u\) can be expressed with matrix
multiplication(s) as shown above.

Currently only the coefficient matrix construction is available. To
solve the diffusion problem user can use any of the available linear
algebra solvers by providing the current diffusing field state
(flattened) and the coefficient matrix on each time-step (or simple
matrix multiplication for time explicit methods).
\begin{itemize}
\item {} 
Simplest options are either \sphinxcode{\sphinxupquote{numpy.linalg.solve()}} or
\sphinxcode{\sphinxupquote{scipy.linalg.solve()}} (both not very fast).

\item {} 
If the coefficient matrix is positive-definite (it is most of the
times, but can be double-checked, specially if errors arise) and
symmetric, a good option is Choleski’s factorization. This is already
implemented in \sphinxcode{\sphinxupquote{scipy.linalg.cholesky()}} which factorizes the
coefficient matrix and that can be passed to the
\sphinxcode{\sphinxupquote{scipy.linalg.cho\_solve()}} which is way faster than the option above.

\item {} 
Another option (but don’t tell anyone) is to invert the coefficient
matrix and just solve the equation with a matrix multiplication. This
is way faster but your coefficient matrix has to be invertible. If
the determinant is close to zero, may cause numerical instability.

\end{itemize}


\subsection{Contents}
\label{\detokenize{diffusion:contents}}\index{build\_mat() (in module data\_tools.diffusion)@\spxentry{build\_mat()}\spxextra{in module data\_tools.diffusion}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{diffusion:data_tools.diffusion.build_mat}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{data\_tools.diffusion.}}\sphinxbfcode{\sphinxupquote{build\_mat}}}{\emph{cent}, \emph{neigh}, \emph{dims}, \emph{bcs='dirichlet'}}{}
Builds a (block) tri-diagonal coefficient matrix to solve a
n-dimensional diffusion problem as a linear algebraic system.
\begin{itemize}
\item {} \begin{description}
\item[{Arguments:}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{cent} {[}float{]}: The coefficient corresponding to the central
element of the stencil.

\item {} 
\sphinxstyleemphasis{neigh} {[}float{]}: The coefficient corresponding to the direct
neighbors of the central element in the stencil.

\item {} 
\sphinxstyleemphasis{dims} {[}list{]}: Or {[}tuple{]}, contains the size of finite
elements {[}int{]} for each dimension. Note that the order is
first dimension first (e.g.: \sphinxcode{\sphinxupquote{{[}x, y, z{]}}}) as opposed to
numpy’s indexing order (last dimension first, e.g.:
\sphinxcode{\sphinxupquote{{[}z, y, x{]}}}).

\item {} 
\sphinxstyleemphasis{bcs} {[}str{]}: Optional, \sphinxcode{\sphinxupquote{'dirichlet'}} by default. Determines
the boundary conditions. Available options are \sphinxcode{\sphinxupquote{'periodic'}},
\sphinxcode{\sphinxupquote{'dirichlet'}} or \sphinxcode{\sphinxupquote{'neumann'}}. Note that Dirichlet BCs do
not hold mass conservation.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Returns:}] \leavevmode\begin{itemize}
\item {} 
{[}numpy.ndarray{]}: The (block) tri-diagonal coefficient matrix.
Matrix will be square with size equal to the product of all
dimension sizes.

\end{itemize}

\end{description}

\end{itemize}

\end{fulllineitems}

\phantomsection\label{\detokenize{iterables:module-data_tools.iterables}}\index{data\_tools.iterables (module)@\spxentry{data\_tools.iterables}\spxextra{module}}

\section{data\_tools.iterables}
\label{\detokenize{iterables:data-tools-iterables}}\label{\detokenize{iterables::doc}}
Iterable-type operations module.


\subsection{Contents}
\label{\detokenize{iterables:contents}}\index{bit\_or() (in module data\_tools.iterables)@\spxentry{bit\_or()}\spxextra{in module data\_tools.iterables}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{iterables:data_tools.iterables.bit_or}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{data\_tools.iterables.}}\sphinxbfcode{\sphinxupquote{bit\_or}}}{\emph{a}, \emph{b}}{}
Returns the bit operation OR between two bit-strings \sphinxstyleemphasis{a} and \sphinxstyleemphasis{b}.
\sphinxstylestrong{NOTE:} \sphinxstyleemphasis{a} and \sphinxstyleemphasis{b} must have the same size.
\begin{itemize}
\item {} \begin{description}
\item[{Arguments:}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{a} {[}tuple{]}: Or any iterable type.

\item {} 
\sphinxstyleemphasis{b} {[}tuple{]}: Or any iterable type.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Returns:}] \leavevmode\begin{itemize}
\item {} 
{[}tuple{]}: OR operation between \sphinxstyleemphasis{a} and \sphinxstyleemphasis{b} element-wise.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Examples:}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{bit\PYGZus{}or}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\PYG{g+go}{(1, 0, 1)}
\end{sphinxVerbatim}

\end{description}

\end{itemize}

\end{fulllineitems}

\index{chunk\_this() (in module data\_tools.iterables)@\spxentry{chunk\_this()}\spxextra{in module data\_tools.iterables}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{iterables:data_tools.iterables.chunk_this}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{data\_tools.iterables.}}\sphinxbfcode{\sphinxupquote{chunk\_this}}}{\emph{L}, \emph{n}}{}
For a given list \sphinxstyleemphasis{L}, returns another list of \sphinxstyleemphasis{n}-sized chunks from
it (in the same order).
\begin{itemize}
\item {} \begin{description}
\item[{Arguments:}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{L} {[}list{]}: The list to be sliced into sublists of the
definded size.

\item {} 
\sphinxstyleemphasis{n} {[}int{]}: The size of the chunks.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Returns:}] \leavevmode\begin{itemize}
\item {} 
{[}list{]}: List of \sphinxstyleemphasis{n}-sized chunks from \sphinxstyleemphasis{L}. \sphinxstylestrong{NOTE:} If the
number of items in \sphinxstyleemphasis{L} is not divisible by \sphinxstyleemphasis{n}, the last
element returned will have an inferior size.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Examples:}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L} \PYG{o}{=} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{chunk\PYGZus{}this}\PYG{p}{(}\PYG{n}{L}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+go}{[[0, 1], [2, 3], [4, 5]]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{chunk\PYGZus{}this}\PYG{p}{(}\PYG{n}{L}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{g+go}{[[0, 1, 2, 3], [4, 5]]}
\end{sphinxVerbatim}

\end{description}

\end{itemize}

\end{fulllineitems}

\index{find\_min() (in module data\_tools.iterables)@\spxentry{find\_min()}\spxextra{in module data\_tools.iterables}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{iterables:data_tools.iterables.find_min}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{data\_tools.iterables.}}\sphinxbfcode{\sphinxupquote{find\_min}}}{\emph{A}}{}
Finds and returns the subset of vectors whose sum is minimum from a
given set \sphinxstyleemphasis{A}.
\begin{itemize}
\item {} \begin{description}
\item[{Arguments:}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{A} {[}set{]}: Set of vectors ({[}tuple{]} or any iterable).

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Returns:}] \leavevmode\begin{itemize}
\item {} 
{[}set{]}: Subset of vectors in \sphinxstyleemphasis{A} whose sum is minimum.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Examples:}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{A} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{find\PYGZus{}min}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}
\PYG{g+go}{set([(0, 1, 0), (1, 0, 0)])}
\end{sphinxVerbatim}

\end{description}

\end{itemize}

\end{fulllineitems}

\index{in\_all() (in module data\_tools.iterables)@\spxentry{in\_all()}\spxextra{in module data\_tools.iterables}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{iterables:data_tools.iterables.in_all}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{data\_tools.iterables.}}\sphinxbfcode{\sphinxupquote{in\_all}}}{\emph{x}, \emph{N}}{}
Checks if a element \sphinxstyleemphasis{x} is present in all collections contained in a
list \sphinxstyleemphasis{N}.
\begin{itemize}
\item {} \begin{description}
\item[{Arguments:}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{x} {[}object{]}: Any type of object, it is assumed to be the same
type as the objects contained in the elements of \sphinxstyleemphasis{N}.

\item {} 
\sphinxstyleemphasis{N} {[}list{]}: Or any iterable type containing a collection of
other iterables containing the objects.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Returns:}] \leavevmode\begin{itemize}
\item {} 
{[}bool{]}: \sphinxcode{\sphinxupquote{True}} if \sphinxstyleemphasis{x} is found in all elements of \sphinxstyleemphasis{N},
\sphinxcode{\sphinxupquote{False}} otherwise.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Examples:}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{N} \PYG{o}{=} \PYG{p}{[}\PYG{p}{\PYGZob{}}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{c+c1}{\PYGZsh{} \PYGZlt{}\PYGZhy{} set A}
\PYG{g+gp}{... }     \PYG{p}{\PYGZob{}}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZcb{}}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{} \PYGZlt{}\PYGZhy{} set B}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{in\PYGZus{}all}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{N}\PYG{p}{)}
\PYG{g+go}{True}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{y} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{in\PYGZus{}all}\PYG{p}{(}\PYG{n}{y}\PYG{p}{,} \PYG{n}{N}\PYG{p}{)}
\PYG{g+go}{False}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{N} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Hello}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{world}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{!}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}
\PYG{g+gp}{... }     \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Hello}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{user}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Hello}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{in\PYGZus{}all}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{N}\PYG{p}{)}
\PYG{g+go}{True}
\end{sphinxVerbatim}

\end{description}

\end{itemize}

\end{fulllineitems}

\index{similarity() (in module data\_tools.iterables)@\spxentry{similarity()}\spxextra{in module data\_tools.iterables}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{iterables:data_tools.iterables.similarity}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{data\_tools.iterables.}}\sphinxbfcode{\sphinxupquote{similarity}}}{\emph{a}, \emph{b}, \emph{mode='j'}}{}
Computes the similarity index between two sets. There are three
options available:

Jaccard (\sphinxcode{\sphinxupquote{mode='j'}}):
\begin{equation*}
\begin{split}s_J(A,B) = \frac{|A\cap B|}{|A\cup B|}\end{split}
\end{equation*}
Sorensen-Dice (\sphinxcode{\sphinxupquote{mode='sd'}}):
\begin{equation*}
\begin{split}s_{SD}(A,B) = \frac{2|A\cap B|}{|A|+|B|}\end{split}
\end{equation*}
Szymkiewicz\textendash{}Simpson (\sphinxcode{\sphinxupquote{mode='ss'}}):
\begin{equation*}
\begin{split}s_{SS}(A,B) = \frac{|A\cap B|}{\min(|A|,|B|)}\end{split}
\end{equation*}\begin{itemize}
\item {} \begin{description}
\item[{Arguments:}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{a} {[}set{]}: One of the two sets to compute the similarity
index.

\item {} 
\sphinxstyleemphasis{b} {[}set{]}: The other set to compute the similarity index.

\item {} 
\sphinxstyleemphasis{mode} {[}str{]}: Optional, \sphinxcode{\sphinxupquote{'j'}} (Jaccard) by default.
Indicates which type of similarity index/coefficient is to be
computed. Available options are: \sphinxcode{\sphinxupquote{'j'}} for Jaccard, \sphinxcode{\sphinxupquote{'sd'}}
for Sorensen-Dice and \sphinxcode{\sphinxupquote{'ss'}} for Szymkiewicz\textendash{}Simpson.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Returns:}] \leavevmode\begin{itemize}
\item {} 
{[}float{]}: The corresponding similarity index/coefficient
according to the specified \sphinxstyleemphasis{mode}.

\end{itemize}

\end{description}

\end{itemize}

\end{fulllineitems}

\index{subsets() (in module data\_tools.iterables)@\spxentry{subsets()}\spxextra{in module data\_tools.iterables}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{iterables:data_tools.iterables.subsets}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{data\_tools.iterables.}}\sphinxbfcode{\sphinxupquote{subsets}}}{\emph{N}}{}
Function that computes all possible logical relations between all
sets on a list \sphinxstyleemphasis{N} and returns all subsets. This is, the subsets
that would represent each intersecting area on a Venn diagram.
\begin{itemize}
\item {} \begin{description}
\item[{Arguments:}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{N} {[}list{]}: Or any iterable type containing {[}set{]} objects.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Returns:}] \leavevmode\begin{itemize}
\item {} 
{[}dict{]}: Collection of subsets according to the logical
relations between the sets in \sphinxstyleemphasis{N}. The keys are binary codes
that denote the logical relation (see examples below).

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Examples:}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{N} \PYG{o}{=} \PYG{p}{[}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{\PYGZcb{}}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{subsets}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}
\PYG{g+go}{\PYGZob{}\PYGZsq{}11\PYGZsq{}: set([2]), \PYGZsq{}10\PYGZsq{}: set([0, 1]), \PYGZsq{}01\PYGZsq{}: set([3, 4])\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{N} \PYG{o}{=} \PYG{p}{[}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{\PYGZcb{}}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{subsets}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}
\PYG{g+go}{\PYGZob{}\PYGZsq{}010\PYGZsq{}: set([2]), \PYGZsq{}011\PYGZsq{}: set([3]), \PYGZsq{}001\PYGZsq{}: set([4]), \PYGZsq{}111\PYGZsq{}: set([}
\PYG{g+go}{]), \PYGZsq{}110\PYGZsq{}: set([]), \PYGZsq{}100\PYGZsq{}: set([0]), \PYGZsq{}101\PYGZsq{}: set([1])\PYGZcb{}}
\end{sphinxVerbatim}

\end{description}

\end{itemize}

\end{fulllineitems}

\index{unzip\_dicts() (in module data\_tools.iterables)@\spxentry{unzip\_dicts()}\spxextra{in module data\_tools.iterables}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{iterables:data_tools.iterables.unzip_dicts}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{data\_tools.iterables.}}\sphinxbfcode{\sphinxupquote{unzip\_dicts}}}{\emph{*dicts}}{}
Unzips the keys and values for any number of dictionaries passed as
arguments (see below for examples).
\begin{itemize}
\item {} \begin{description}
\item[{Arguments:}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{*dicts} {[}dict{]}: Dictionaries from which key/value pairs are
to be unzipped.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Returns:}] \leavevmode\begin{itemize}
\item {} 
{[}list{]}: Two-element list contianing all keys and all values
respectively from the dictionaries in \sphinxstyleemphasis{*dicts}.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Example:}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{n+nb}{dict}\PYG{p}{(}\PYG{p}{[}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{x\PYGZus{}a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{y\PYGZus{}a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{b} \PYG{o}{=} \PYG{n+nb}{dict}\PYG{p}{(}\PYG{p}{[}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{x\PYGZus{}b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{y\PYGZus{}b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{unzip\PYGZus{}dicts}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\PYG{g+go}{[(\PYGZsq{}y\PYGZus{}a\PYGZsq{}, \PYGZsq{}x\PYGZus{}a\PYGZsq{}, \PYGZsq{}x\PYGZus{}b\PYGZsq{}, \PYGZsq{}y\PYGZus{}b\PYGZsq{}), (3, 2, 1, \PYGZhy{}1)]}
\end{sphinxVerbatim}

\end{description}

\end{itemize}

\end{fulllineitems}

\phantomsection\label{\detokenize{models:module-data_tools.models}}\index{data\_tools.models (module)@\spxentry{data\_tools.models}\spxextra{module}}

\section{data\_tools.models}
\label{\detokenize{models:data-tools-models}}\label{\detokenize{models::doc}}
Model classes module.


\subsection{Contents}
\label{\detokenize{models:contents}}\index{DoseResponse (class in data\_tools.models)@\spxentry{DoseResponse}\spxextra{class in data\_tools.models}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{models:data_tools.models.DoseResponse}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{data\_tools.models.}}\sphinxbfcode{\sphinxupquote{DoseResponse}}}{\emph{d\_data, r\_data, x0=None, x\_scale=None, bounds=({[}0, 0, -inf{]}, {[}inf, inf, inf{]})}}{}
Wrapper class for \sphinxcode{\sphinxupquote{scipy.optimize.least\_squares}} to fit
dose-response curves on a pre-defined Hill function with the
following form:
\begin{equation*}
\begin{split}R=\frac{mD^n}{k^n+D^n}\end{split}
\end{equation*}
Where \(D\) is the dose, \(k\), \(m\) and \(n\) are
the parameters to be fitted.
\begin{itemize}
\item {} \begin{description}
\item[{Arguments:}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{d\_data} {[}numpy.ndarray{]}: Or any iterable (1D). Contains the
training data corresponding to the dose.

\item {} 
\sphinxstyleemphasis{r\_data} {[}numpy.ndarray{]}: Or any iterable (1D). Contains the
training data corresponding to the response.

\item {} 
\sphinxstyleemphasis{x0} {[}list{]}: Optional, \sphinxcode{\sphinxupquote{None}} by default. Or any
iterable of three elements. Contains the initial guess for the
parameters. Parameters are considered to be in alphabetical
order. This is, first element corresponds to \(k\), second
is \(m\) and last is \(n\). If \sphinxcode{\sphinxupquote{None}} (default), the
initial guess is inferred from \sphinxstyleemphasis{r\_data}.

\item {} 
\sphinxstyleemphasis{x\_scale} {[}list{]}: Optional, \sphinxcode{\sphinxupquote{None}} by default. Or any
iterable of three elements. Scale of each parameter. May
improve the fitting if the scaled parameters have similar
effect on the cost function. If \sphinxcode{\sphinxupquote{None}} (default), the scale
is inferred from \sphinxstyleemphasis{x0}.

\item {} 
\sphinxstyleemphasis{bounds} {[}tuple{]}: Optional \sphinxcode{\sphinxupquote{({[}0, 0, -inf{]}, {[}inf, inf, inf{]})}}
by default. Two-element tuple containing the lower and upper
boundaries for the parameters (elements of the tuple are
iterables of three elements each).

\end{itemize}

\end{description}

\end{itemize}
\begin{itemize}
\item {} \begin{description}
\item[{Attributes:}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{x0} {[}list{]}: Contains the initial guess for the parameters.
Parameters are considered to be in alphabetical order. This
is, first element corresponds to \(k\), second is
\(m\) and last is \(n\).

\item {} 
\sphinxstyleemphasis{x\_scale} {[}list{]}: Scale of each parameter.

\item {} 
\sphinxstyleemphasis{model} {[}scipy.optimize.OptimizeResult{]}: Contains the result
of the optimized model. See \sphinxhref{https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.OptimizeResult.html\#scipy.optimize.OptimizeResult}{SciPy’s reference} for more
information.

\item {} 
\sphinxstyleemphasis{params} {[}numpy.ndarray{]}: Three-element array containing the
fitted parameters \(k\), \(m\) and \(n\).

\end{itemize}

\end{description}

\end{itemize}
\index{ec() (data\_tools.models.DoseResponse method)@\spxentry{ec()}\spxextra{data\_tools.models.DoseResponse method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{models:data_tools.models.DoseResponse.ec}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{ec}}}{\emph{p=50}}{}
Computes the effective concentration for the specified
percentage of maximal concentration (\(EC_{p}\)).
\begin{itemize}
\item {} \begin{description}
\item[{Arguments:}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{p} {[}int{]}: Optional, \sphinxcode{\sphinxupquote{50}} by default (\(EC_{50}\)).
Defines the percentage of the maximal from which the
effective concentration is to be computed.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Returns}] \leavevmode\begin{itemize}
\item {} 
{[}float{]}: Value of the \(EC_{p}\) computed according
to the model parameters.

\end{itemize}

\end{description}

\end{itemize}

\end{fulllineitems}

\index{plot() (data\_tools.models.DoseResponse method)@\spxentry{plot()}\spxextra{data\_tools.models.DoseResponse method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{models:data_tools.models.DoseResponse.plot}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{plot}}}{\emph{title=None}, \emph{filename=None}, \emph{figsize=None}, \emph{legend=True}}{}
Plots the data points and the fitted function together.
\begin{itemize}
\item {} \begin{description}
\item[{Arguments:}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{title} {[}str{]}: Optional, \sphinxcode{\sphinxupquote{None}} by default. Defines the
plot title.

\item {} 
\sphinxstyleemphasis{filename} {[}str{]}: Optional, \sphinxcode{\sphinxupquote{None}} by default. If
passed, indicates the file name or path where to store the
figure. Format must be specified (e.g.: .png, .pdf, etc)

\item {} 
\sphinxstyleemphasis{figsize} {[}tuple{]}: Optional, \sphinxcode{\sphinxupquote{None}} by default (default
matplotlib size). Any iterable containing two values
denoting the figure size (in inches) as {[}width, height{]}.

\item {} 
\sphinxstyleemphasis{legend} {[}bool{]}: Optional, \sphinxcode{\sphinxupquote{True}} by default. Indicates
whether to show the plot legend or not.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Returns:}] \leavevmode\begin{itemize}
\item {} 
{[}matplotlib.figure.Figure{]}: Figure object showing the data
points and the fitted model function.

\end{itemize}

\end{description}

\end{itemize}

\end{fulllineitems}


\end{fulllineitems}

\index{Lasso (class in data\_tools.models)@\spxentry{Lasso}\spxextra{class in data\_tools.models}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{models:data_tools.models.Lasso}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{data\_tools.models.}}\sphinxbfcode{\sphinxupquote{Lasso}}}{\emph{Cs=500}, \emph{cv=10}, \emph{sampler='skf'}, \emph{solver='liblinear'}, \emph{**kwargs}}{}
Wrapper class inheriting from
\sphinxcode{\sphinxupquote{sklearn.linear\_model.LogisticRegressionCV}} with L1
regularization.
\begin{itemize}
\item {} \begin{description}
\item[{Arguments:}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{Cs} {[}int{]}: Optional, \sphinxcode{\sphinxupquote{500}} by default. Integer or list of
float values of regularization parameters to test. If an
integer is passed, it will determine the number of values
taken from a logarithmic scale between \sphinxcode{\sphinxupquote{1e-4}} and \sphinxcode{\sphinxupquote{1e4}}.
Note that the value of the parameter is defined as the inverse
of the regularization strength.

\item {} 
\sphinxstyleemphasis{cv} {[}int{]}: Optional, \sphinxcode{\sphinxupquote{10}} by default. Denotes the number of
cross validation (CV) folds.

\item {} 
\sphinxstyleemphasis{sampler} {[}str{]}: Optional, \sphinxcode{\sphinxupquote{'skf'}} by default. Determines
which sampling method is used to generate the test and
training sets for CV. Methods available are K-Fold (\sphinxcode{\sphinxupquote{'kf'}}),
Shuffle Split (\sphinxcode{\sphinxupquote{'ss'}}) and their stratified variants
(\sphinxcode{\sphinxupquote{'skf'}} and \sphinxcode{\sphinxupquote{'sss'}} respectively).

\item {} 
\sphinxstyleemphasis{solver} {[}str{]}: Optional, \sphinxcode{\sphinxupquote{'liblinear'}} by default.
Determines which solver algorithm to use. Note that L1
regularization can only be handled by \sphinxcode{\sphinxupquote{'liblinear'}} and
\sphinxcode{\sphinxupquote{'saga'}}. Additionally if the classification is multinomial,
only the latter option is available.

\item {} 
\sphinxstyleemphasis{**kwargs}: Optional. Any other keyword argument accepted by
the \sphinxcode{\sphinxupquote{sklearn.linear\_model.LogisticRegressionCV}} class.

\end{itemize}

Other keyword arguments and functions available from the parent
class \sphinxcode{\sphinxupquote{LogisticRegressionCV}} can be fount in \sphinxhref{http://scikit-learn.org/stable/modules/generated/sklearn.linear\_model.LogisticRegressionCV.html}{Scikit-Learn’s
reference}.

\end{description}

\end{itemize}
\index{fit\_data() (data\_tools.models.Lasso method)@\spxentry{fit\_data()}\spxextra{data\_tools.models.Lasso method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{models:data_tools.models.Lasso.fit_data}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{fit\_data}}}{\emph{x}, \emph{y}, \emph{silent=False}}{}
Fits the data to the logistic model.
\begin{itemize}
\item {} \begin{description}
\item[{Arguments:}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{x} {[}pandas.DataFrame{]}: Contains the values/measurements
{[}float{]} of the features (columns) for each
sample/replicate (rows).

\item {} 
\sphinxstyleemphasis{y} {[}pandas.Series{]}: List or any iterable containing the
observed class of each sample (must have the same order as
in \sphinxstyleemphasis{x}).

\item {} 
\sphinxstyleemphasis{silent} {[}bool{]}: Optional, \sphinxcode{\sphinxupquote{False}} by default.
Determines whether messages are printed or not.

\end{itemize}

\end{description}

\end{itemize}

\end{fulllineitems}

\index{plot\_coef() (data\_tools.models.Lasso method)@\spxentry{plot\_coef()}\spxextra{data\_tools.models.Lasso method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{models:data_tools.models.Lasso.plot_coef}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{plot\_coef}}}{\emph{filename=None}, \emph{figsize=None}}{}
Plots the non-zero coefficients for the fitted predictor
features.
\begin{itemize}
\item {} \begin{description}
\item[{Arguments:}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{filename} {[}str{]}: Optional, \sphinxcode{\sphinxupquote{None}} by default. If
passed, indicates the file name or path where to store the
figure. Format must be specified (e.g.: .png, .pdf, etc)

\item {} 
\sphinxstyleemphasis{figsize} {[}tuple{]}: Optional, \sphinxcode{\sphinxupquote{None}} by default (default
matplotlib size). Any iterable containing two values
denoting the figure size (in inches) as {[}width, height{]}.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Returns:}] \leavevmode\begin{itemize}
\item {} 
{[}matplotlib.figure.Figure{]}: Figure object containing the
bar plot of the non-zero coefficients.

\end{itemize}

\end{description}

\end{itemize}

\end{fulllineitems}

\index{plot\_score() (data\_tools.models.Lasso method)@\spxentry{plot\_score()}\spxextra{data\_tools.models.Lasso method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{models:data_tools.models.Lasso.plot_score}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{plot\_score}}}{\emph{filename=None}, \emph{figsize=None}}{}
Plots the mean score across all folds obtained during CV.
The optimum C parameter chosen and its score are highlighted.
\begin{itemize}
\item {} \begin{description}
\item[{Arguments:}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{filename} {[}str{]}: Optional, \sphinxcode{\sphinxupquote{None}} by default. If
passed, indicates the file name or path where to store the
figure. Format must be specified (e.g.: .png, .pdf, etc)

\item {} 
\sphinxstyleemphasis{figsize} {[}tuple{]}: Optional, \sphinxcode{\sphinxupquote{None}} by default (default
matplotlib size). Any iterable containing two values
denoting the figure size (in inches) as {[}width, height{]}.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Returns:}] \leavevmode\begin{itemize}
\item {} 
{[}matplotlib.figure.Figure{]}: Figure object containing the
score plot.

\end{itemize}

\end{description}

\end{itemize}

\end{fulllineitems}


\end{fulllineitems}

\phantomsection\label{\detokenize{plots:module-data_tools.plots}}\index{data\_tools.plots (module)@\spxentry{data\_tools.plots}\spxextra{module}}

\section{data\_tools.plots}
\label{\detokenize{plots:data-tools-plots}}\label{\detokenize{plots::doc}}
Plotting functions module.


\subsection{Contents}
\label{\detokenize{plots:contents}}\index{cmap\_bkgr (in module data\_tools.plots)@\spxentry{cmap\_bkgr}\spxextra{in module data\_tools.plots}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{plots:data_tools.plots.cmap_bkgr}}\pysigline{\sphinxcode{\sphinxupquote{data\_tools.plots.}}\sphinxbfcode{\sphinxupquote{cmap\_bkgr}}\sphinxbfcode{\sphinxupquote{ = \textless{}matplotlib.colors.LinearSegmentedColormap object\textgreater{}}}}
Custom colormap, gradient from black (lowest) to lime green (highest).

\end{fulllineitems}

\index{cmap\_bkrd (in module data\_tools.plots)@\spxentry{cmap\_bkrd}\spxextra{in module data\_tools.plots}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{plots:data_tools.plots.cmap_bkrd}}\pysigline{\sphinxcode{\sphinxupquote{data\_tools.plots.}}\sphinxbfcode{\sphinxupquote{cmap\_bkrd}}\sphinxbfcode{\sphinxupquote{ = \textless{}matplotlib.colors.LinearSegmentedColormap object\textgreater{}}}}
Custom colormap, gradient from black (lowest) to red (highest).

\end{fulllineitems}

\index{cmap\_rdbkgr (in module data\_tools.plots)@\spxentry{cmap\_rdbkgr}\spxextra{in module data\_tools.plots}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{plots:data_tools.plots.cmap_rdbkgr}}\pysigline{\sphinxcode{\sphinxupquote{data\_tools.plots.}}\sphinxbfcode{\sphinxupquote{cmap\_rdbkgr}}\sphinxbfcode{\sphinxupquote{ = \textless{}matplotlib.colors.LinearSegmentedColormap object\textgreater{}}}}
Custom colormap, gradient from red (lowest) to black (middle) to lime
green (highest).

\end{fulllineitems}

\index{density() (in module data\_tools.plots)@\spxentry{density()}\spxextra{in module data\_tools.plots}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{plots:data_tools.plots.density}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{data\_tools.plots.}}\sphinxbfcode{\sphinxupquote{density}}}{\emph{df}, \emph{cvf=0.25}, \emph{sample\_col=False}, \emph{title=None}, \emph{filename=None}, \emph{figsize=None}}{}
Generates a density plot of the values on a data frame (row-wise).
\begin{itemize}
\item {} \begin{description}
\item[{Arguments:}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{df} {[}pandas.DataFrame{]}: Contains the values to generate the
plot. Each row is considered as an individual sample while
each column contains a measured value unless otherwise stated
by keyword argument \sphinxstyleemphasis{sample\_col}.

\item {} 
\sphinxstyleemphasis{cvf} {[}float{]}: Optional, \sphinxcode{\sphinxupquote{0.25}} by default. Co-variance
factor used in the gaussian kernel estimation. A higher value
increases the smoothness.

\item {} 
\sphinxstyleemphasis{sample\_col} {[}bool{]}: Optional, \sphinxcode{\sphinxupquote{False}} by default. Specifies
whether the samples are column-wise or not.

\item {} 
\sphinxstyleemphasis{title} {[}str{]}: Optional, \sphinxcode{\sphinxupquote{None}} by default. Defines the plot
title.

\item {} 
\sphinxstyleemphasis{filename} {[}str{]}: Optional, \sphinxcode{\sphinxupquote{None}} by default. If passed,
indicates the file name or path where to store the figure.
Format must be specified (e.g.: .png, .pdf, etc)

\item {} 
\sphinxstyleemphasis{figsize} {[}tuple{]}: Optional, \sphinxcode{\sphinxupquote{None}} by default (default
matplotlib size). Any iterable containing two values denoting
the figure size (in inches) as {[}width, height{]}.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Returns:}] \leavevmode\begin{itemize}
\item {} 
{[}matplotlib.figure.Figure{]}: the figure object containing the
density plot, unless \sphinxstyleemphasis{filename} is provided.

\end{itemize}

\end{description}

\end{itemize}

\end{fulllineitems}

\index{piano\_consensus() (in module data\_tools.plots)@\spxentry{piano\_consensus()}\spxextra{in module data\_tools.plots}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{plots:data_tools.plots.piano_consensus}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{data\_tools.plots.}}\sphinxbfcode{\sphinxupquote{piano\_consensus}}}{\emph{df}, \emph{nchar=40}, \emph{boxes=True}, \emph{title=None}, \emph{filename=None}, \emph{figsize=None}}{}
Generates a GSEA consensus score plot like R package \sphinxcode{\sphinxupquote{piano}}’s
\sphinxcode{\sphinxupquote{consensusScores}} function, but prettier.
The main input is assumed to be a \sphinxcode{\sphinxupquote{pandas.DataFrame}} whose data
is the same as the \sphinxcode{\sphinxupquote{rankMat}} from the result of
\sphinxcode{\sphinxupquote{consensusScores}}.
\begin{itemize}
\item {} \begin{description}
\item[{Arguments:}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{df} {[}pandas.DataFrame{]}: Values contained correspond to the
scores of the gene-sets (consensus and each individual
methods). Index must contain the gene-set labels. Columns are
assumed to be \sphinxcode{\sphinxupquote{ConsRank}} (ignored), \sphinxcode{\sphinxupquote{ConsScore}} followed
by the individual methods (e.g.: \sphinxcode{\sphinxupquote{mean}}, \sphinxcode{\sphinxupquote{median}},
\sphinxcode{\sphinxupquote{sum}}, etc).

\item {} 
\sphinxstyleemphasis{nchar} {[}int{]}: Optional, \sphinxcode{\sphinxupquote{40}} by default. Number of string
characters of the gene-set labels of the plot.

\item {} 
\sphinxstyleemphasis{boxes} {[}bool{]}: Optional, \sphinxcode{\sphinxupquote{True}} by default. Determines
whether to show the boxplots of the gene-sets or not.

\item {} 
\sphinxstyleemphasis{title} {[}str{]}: Optional, \sphinxcode{\sphinxupquote{None}} by default. Defines the plot
title.

\item {} 
\sphinxstyleemphasis{filename} {[}str{]}: Optional, \sphinxcode{\sphinxupquote{None}} by default. If passed,
indicates the file name or path where to store the figure.
Format must be specified (e.g.: .png, .pdf, etc)

\item {} 
\sphinxstyleemphasis{figsize} {[}tuple{]}: Optional, \sphinxcode{\sphinxupquote{None}} by default (default
matplotlib size). Any iterable containing two values denoting
the figure size (in inches) as {[}width, height{]}.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Returns:}] \leavevmode\begin{itemize}
\item {} 
{[}matplotlib.figure.Figure{]}: the figure object containing a
combination of box and scatter plots of the gene-set scores,
unless \sphinxstyleemphasis{filename} is provided.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Example:}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{piano\PYGZus{}consensus}\PYG{p}{(}\PYG{n}{df}\PYG{p}{,} \PYG{n}{figsize}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent{\hspace*{\fill}\sphinxincludegraphics[scale=0.6]{{piano_consensus_example}.png}\hspace*{\fill}}

\end{description}

\end{itemize}

\end{fulllineitems}

\index{similarity\_heatmap() (in module data\_tools.plots)@\spxentry{similarity\_heatmap()}\spxextra{in module data\_tools.plots}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{plots:data_tools.plots.similarity_heatmap}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{data\_tools.plots.}}\sphinxbfcode{\sphinxupquote{similarity\_heatmap}}}{\emph{groups}, \emph{labels=None}, \emph{mode='j'}, \emph{cmap='nipy\_spectral'}, \emph{title=None}, \emph{filename=None}, \emph{figsize=None}}{}
Given a group of sets, generates a heatmap with the similarity
indices across each possible pair.
\begin{itemize}
\item {} \begin{description}
\item[{Arguments:}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{groups} {[}list{]}: Or any iterable of {[}set{]} objects.

\item {} 
\sphinxstyleemphasis{labels} {[}list{]}: Optional, \sphinxcode{\sphinxupquote{None}} by default. Labels for the
sets following the same order as provided in \sphinxstyleemphasis{groups}.

\item {} 
\sphinxstyleemphasis{mode} {[}str{]}: Optional, \sphinxcode{\sphinxupquote{'j'}} (Jaccard) by default.
Indicates which type of similarity index/coefficient is to be
computed. Available options are: \sphinxcode{\sphinxupquote{'j'}} for Jaccard, \sphinxcode{\sphinxupquote{'sd'}}
for Sorensen-Dice and \sphinxcode{\sphinxupquote{'ss'}} for Szymkiewicz\textendash{}Simpson. See
{\hyperref[\detokenize{iterables:data_tools.iterables.similarity}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{data\_tools.iterables.similarity()}}}}} for more
information.

\item {} 
\sphinxstyleemphasis{cmap} {[}str{]}: Optional, \sphinxcode{\sphinxupquote{'nipy\_spectral'}} by default. The
colormap used for the plot (can also be a
{[}matplotlib.colors.Colormap{]} object). See other {[}str{]} options
available in \sphinxhref{https://matplotlib.org/examples/color/colormaps\_reference.html}{Matplotlib’s reference manual}.

\item {} 
\sphinxstyleemphasis{title} {[}str{]}: Optional, \sphinxcode{\sphinxupquote{None}} by default. Defines the plot
title.

\item {} 
\sphinxstyleemphasis{filename} {[}str{]}: Optional, \sphinxcode{\sphinxupquote{None}} by default. If passed,
indicates the file name or path where to store the figure.
Format must be specified (e.g.: .png, .pdf, etc)

\item {} 
\sphinxstyleemphasis{figsize} {[}tuple{]}: Optional, \sphinxcode{\sphinxupquote{None}} by default (default
matplotlib size). Any iterable containing two values denoting
the figure size (in inches) as {[}width, height{]}.

\end{itemize}

\end{description}

\end{itemize}
\begin{itemize}
\item {} \begin{description}
\item[{Returns:}] \leavevmode\begin{itemize}
\item {} 
{[}matplotlib.figure.Figure{]}: the figure object containing a
combination of box and scatter plots of the gene-set scores,
unless \sphinxstyleemphasis{filename} is provided.

\end{itemize}

\end{description}

\end{itemize}

\end{fulllineitems}

\index{similarity\_histogram() (in module data\_tools.plots)@\spxentry{similarity\_histogram()}\spxextra{in module data\_tools.plots}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{plots:data_tools.plots.similarity_histogram}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{data\_tools.plots.}}\sphinxbfcode{\sphinxupquote{similarity\_histogram}}}{\emph{groups}, \emph{mode='j'}, \emph{bins=10}, \emph{title=None}, \emph{filename=None}, \emph{figsize=None}}{}
Given a group of sets, generates a histogram of the similarity
indices across each possible pair (same-element pairs excluded).
\begin{itemize}
\item {} \begin{description}
\item[{Arguments:}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{groups} {[}list{]}: Or any iterable of {[}set{]} objects.

\item {} 
\sphinxstyleemphasis{mode} {[}str{]}: Optional, \sphinxcode{\sphinxupquote{'j'}} (Jaccard) by default.
Indicates which type of similarity index/coefficient is to be
computed. Available options are: \sphinxcode{\sphinxupquote{'j'}} for Jaccard, \sphinxcode{\sphinxupquote{'sd'}}
for Sorensen-Dice and \sphinxcode{\sphinxupquote{'ss'}} for Szymkiewicz\textendash{}Simpson. See
{\hyperref[\detokenize{iterables:data_tools.iterables.similarity}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{data\_tools.iterables.similarity()}}}}} for more
information.

\item {} 
\sphinxstyleemphasis{bins} {[}int{]}: Optional, \sphinxcode{\sphinxupquote{10}} by default. Number of bins to
show in the histogram.

\item {} 
\sphinxstyleemphasis{title} {[}str{]}: Optional, \sphinxcode{\sphinxupquote{None}} by default. Defines the plot
title.

\item {} 
\sphinxstyleemphasis{filename} {[}str{]}: Optional, \sphinxcode{\sphinxupquote{None}} by default. If passed,
indicates the file name or path where to store the figure.
Format must be specified (e.g.: .png, .pdf, etc)

\item {} 
\sphinxstyleemphasis{figsize} {[}tuple{]}: Optional, \sphinxcode{\sphinxupquote{None}} by default (default
matplotlib size). Any iterable containing two values denoting
the figure size (in inches) as {[}width, height{]}.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Returns:}] \leavevmode\begin{itemize}
\item {} 
{[}matplotlib.figure.Figure{]}: the figure object containing a
combination of box and scatter plots of the gene-set scores,
unless \sphinxstyleemphasis{filename} is provided.

\end{itemize}

\end{description}

\end{itemize}

\end{fulllineitems}

\index{upset\_wrap() (in module data\_tools.plots)@\spxentry{upset\_wrap()}\spxextra{in module data\_tools.plots}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{plots:data_tools.plots.upset_wrap}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{data\_tools.plots.}}\sphinxbfcode{\sphinxupquote{upset\_wrap}}}{\emph{N}, \emph{labels=None}, \emph{drop\_empty=False}, \emph{**kwargs}}{}
Wrapper for UpSetPlot package. Mostly just generates the Boolean
multi-indexed \sphinxcode{\sphinxupquote{pandas.Series}} the \sphinxcode{\sphinxupquote{upsetplot.plot}} function
needs as input.
\begin{itemize}
\item {} \begin{description}
\item[{Arguments:}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{N} {[}list{]}: Or any iterable type containing {[}set{]} objects.

\item {} 
\sphinxstyleemphasis{labels} {[}list{]}: Optional, \sphinxcode{\sphinxupquote{None}} by default. Labels for the
sets following the same order as provided in \sphinxstyleemphasis{N}. If none is
passed they will be labelled \sphinxcode{\sphinxupquote{'set0'}}, \sphinxcode{\sphinxupquote{'set1'}} and so on.

\item {} 
\sphinxstyleemphasis{drop\_empty} {[}bool{]}: Optional, \sphinxcode{\sphinxupquote{False}} by default. Whether
to remove the empty set intersections from the plot or not.

\item {} 
\sphinxstyleemphasis{**kwargs}: Optional. Additional keyword arguments passed to
\sphinxcode{\sphinxupquote{upsetplot.UpSet}} class.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Returns:}] \leavevmode
{[}dict{]}: Contains the \sphinxcode{\sphinxupquote{matplotlib.axes.Axes}} instances for the
UpSetPlot figure.

\end{description}

\end{itemize}

\end{fulllineitems}

\index{venn() (in module data\_tools.plots)@\spxentry{venn()}\spxextra{in module data\_tools.plots}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{plots:data_tools.plots.venn}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{data\_tools.plots.}}\sphinxbfcode{\sphinxupquote{venn}}}{\emph{N, labels={[}'A', 'B', 'C', 'D', 'E'{]}, c={[}'C0', 'C1', 'C2', 'C3', 'C4'{]}, pct=False, sizes=False, title=None, filename=None, figsize=None}}{}
Plots a Venn diagram from a list of sets \sphinxstyleemphasis{N}. Number of sets must be
between 2 and 5 (inclusive).
\begin{itemize}
\item {} \begin{description}
\item[{Arguments:}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{N} {[}list{]}: Or any iterable type containing {[}set{]} objects.

\item {} 
\sphinxstyleemphasis{labels} {[}list{]}: Optional, \sphinxcode{\sphinxupquote{{[}'A', 'B', 'C', 'D', 'E'{]}}} by
default. Labels for the sets following the same order as
provided in \sphinxstyleemphasis{N}.

\item {} 
\sphinxstyleemphasis{c} {[}list{]}: Optional, \sphinxcode{\sphinxupquote{{[}'C0', 'C1' 'C2', 'C3', 'C4'{]}}} by
default (matplotlib default colors). Any iterable containing
color arguments tolerated by matplotlib (e.g.: \sphinxcode{\sphinxupquote{{[}'r', 'b'{]}}}
for red and blue). Must contain at least the same number of
elements as \sphinxstyleemphasis{N} (if more are provided, they will be ignored).

\item {} 
\sphinxstyleemphasis{pct} {[}bool{]}: Optional, \sphinxcode{\sphinxupquote{False}} by default. Indicates
whether to show percentages instead of absolute counts.

\item {} 
\sphinxstyleemphasis{sizes} {[}bool{]}: Optional, \sphinxcode{\sphinxupquote{False}} by default. Whether to
include the size of the sets in the legend or not.

\item {} 
\sphinxstyleemphasis{title} {[}str{]}: Optional, \sphinxcode{\sphinxupquote{None}} by default. Defines the plot
title.

\item {} 
\sphinxstyleemphasis{filename} {[}str{]}: Optional, \sphinxcode{\sphinxupquote{None}} by default. If passed,
indicates the file name or path where to store the figure.
Format must be specified (e.g.: .png, .pdf, etc)

\item {} 
\sphinxstyleemphasis{figsize} {[}tuple{]}: Optional, \sphinxcode{\sphinxupquote{None}} by default (default
matplotlib size). Any iterable containing two values denoting
the figure size (in inches) as {[}width, height{]}.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Returns:}] \leavevmode\begin{itemize}
\item {} 
{[}matplotlib.figure.Figure{]}: the figure object containing a
combination of box and scatter plots of the gene-set scores,
unless \sphinxstyleemphasis{filename} is provided.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Example:}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{N} \PYG{o}{=} \PYG{p}{[}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{\PYGZcb{}}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{} Sets A, B, C}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{venn}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent{\hspace*{\fill}\sphinxincludegraphics[scale=1.0]{{venn_example}.png}\hspace*{\fill}}

\end{description}

\end{itemize}

\end{fulllineitems}

\index{volcano() (in module data\_tools.plots)@\spxentry{volcano()}\spxextra{in module data\_tools.plots}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{plots:data_tools.plots.volcano}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{data\_tools.plots.}}\sphinxbfcode{\sphinxupquote{volcano}}}{\emph{logfc}, \emph{logpval}, \emph{thr\_pval=0.05}, \emph{thr\_fc=2.0}, \emph{c=('C0'}, \emph{'C1')}, \emph{legend=True}, \emph{title=None}, \emph{filename=None}, \emph{figsize=None}}{}
Generates a volcano plot from the differential expression data
provided.
\begin{itemize}
\item {} \begin{description}
\item[{Arguments:}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{logfc} {[}list{]}: Or any iterable type. Contains the log
(usually base 2) fold-change values. Must have the same length
as \sphinxstyleemphasis{logpval}.

\item {} 
\sphinxstyleemphasis{logpval} {[}list{]}: Or any iterable type. Contains the -log
p-values (usually base 10). Must have the same length as
\sphinxstyleemphasis{logfc}.

\item {} 
\sphinxstyleemphasis{thr\_pval} {[}float{]}: Optional, \sphinxcode{\sphinxupquote{0.05}} by default. Specifies
the p-value (non log-transformed) threshold to consider a
measurement as significantly differentially expressed.

\item {} 
\sphinxstyleemphasis{thr\_fc} {[}float{]}: Optional, \sphinxcode{\sphinxupquote{2}}. by default. Specifies the
FC (non log-transformed) threshold to consider a measurement
as significantly differentially expressed.

\item {} 
\sphinxstyleemphasis{c} {[}tuple{]}: Optional, \sphinxcode{\sphinxupquote{('C0', 'C1')}} by default (matplotlib
default colors). Any iterable containing two color arguments
tolerated by matplotlib (e.g.: \sphinxcode{\sphinxupquote{{[}'r', 'b'{]}}} for red and
blue). First one is used for non-significant points, second
for the significant ones.

\item {} 
\sphinxstyleemphasis{legend} {[}bool{]}: Optional, \sphinxcode{\sphinxupquote{True}} by default. Indicates
whether to show the plot legend or not.

\item {} 
\sphinxstyleemphasis{title} {[}str{]}: Optional, \sphinxcode{\sphinxupquote{None}} by default. Defines the plot
title.

\item {} 
\sphinxstyleemphasis{filename} {[}str{]}: Optional, \sphinxcode{\sphinxupquote{None}} by default. If passed,
indicates the file name or path where to store the figure.
Format must be specified (e.g.: .png, .pdf, etc)

\item {} 
\sphinxstyleemphasis{figsize} {[}tuple{]}: Optional, \sphinxcode{\sphinxupquote{None}} by default (default
matplotlib size). Any iterable containing two values denoting
the figure size (in inches) as {[}width, height{]}.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Returns:}] \leavevmode\begin{itemize}
\item {} 
{[}matplotlib.figure.Figure{]}: Figure object containing the
volcano plot, unless \sphinxstyleemphasis{filename} is provided.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Example:}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{volcano}\PYG{p}{(}\PYG{n}{my\PYGZus{}log\PYGZus{}fc}\PYG{p}{,} \PYG{n}{my\PYGZus{}log\PYGZus{}pval}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent{\hspace*{\fill}\sphinxincludegraphics[scale=0.6]{{volcano_example}.png}\hspace*{\fill}}

\end{description}

\end{itemize}

\end{fulllineitems}

\phantomsection\label{\detokenize{signal:module-data_tools.signal}}\index{data\_tools.signal (module)@\spxentry{data\_tools.signal}\spxextra{module}}

\section{data\_tools.signal}
\label{\detokenize{signal:data-tools-signal}}\label{\detokenize{signal::doc}}
Signal processing module.


\subsection{Contents}
\label{\detokenize{signal:contents}}\index{fconvolve() (in module data\_tools.signal)@\spxentry{fconvolve()}\spxextra{in module data\_tools.signal}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{signal:data_tools.signal.fconvolve}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{data\_tools.signal.}}\sphinxbfcode{\sphinxupquote{fconvolve}}}{\emph{u}, \emph{v}}{}
Convolves two vectors or arrays using Fast Fourier Transform (FFT).
According to Fourier theory, the convolution theorem states that:
\begin{equation*}
\begin{split}g(x)=u(x)\ast v(x)=\mathcal{F}^{-1}\left\{\mathcal{F}\{u(x)
\}\mathcal{F}\{v(x)\}\right\}\end{split}
\end{equation*}\begin{itemize}
\item {} \begin{description}
\item[{Arguments:}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{u} {[}numpy.ndarray{]}: First array to convolve.

\item {} 
\sphinxstyleemphasis{v} {[}numpy.ndarray{]}: The other array to be convolved.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Returns:}] \leavevmode\begin{itemize}
\item {} 
{[}numpy.ndarray{]}: The convolved array of \sphinxstyleemphasis{u} and \sphinxstyleemphasis{v}.

\end{itemize}

\end{description}

\end{itemize}

\end{fulllineitems}

\index{gauss\_kernel() (in module data\_tools.signal)@\spxentry{gauss\_kernel()}\spxextra{in module data\_tools.signal}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{signal:data_tools.signal.gauss_kernel}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{data\_tools.signal.}}\sphinxbfcode{\sphinxupquote{gauss\_kernel}}}{\emph{size}, \emph{sd=1}, \emph{ndim=2}}{}
Returns a N-dimensional Gaussian kernel. The kernel is defined as
follows:
\begin{equation*}
\begin{split}k(\vec{x})=\frac{1}{(\sqrt{2\pi}\sigma)^N}\mathrm{e}^{-
\frac{||\vec{x}||_2^2}{2\sigma^2}}\end{split}
\end{equation*}
Where :math{}`N{}` is the number of dimensions and \(\sigma\) is
the standard deviation of the kernel.
\begin{itemize}
\item {} \begin{description}
\item[{Arguments:}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{size} {[}int{]}: The number of discrete points of the kernel
(will be the same on each dimension).

\item {} 
\sphinxstyleemphasis{sd} {[}float{]}: Optional, \sphinxcode{\sphinxupquote{1}} by default. The standard
deviation of the gaussian kernel.

\item {} 
\sphinxstyleemphasis{ndim} {[}int{]}: Optional, \sphinxcode{\sphinxupquote{2}} by default. Number of dimensions

\end{itemize}

for the desired kernel.

\end{description}

\item {} \begin{description}
\item[{Returns:}] \leavevmode\begin{itemize}
\item {} 
{[}numpy.ndarray{]}: The Gaussian kernel.

\end{itemize}

\end{description}

\end{itemize}

\end{fulllineitems}

\index{gauss\_noise() (in module data\_tools.signal)@\spxentry{gauss\_noise()}\spxextra{in module data\_tools.signal}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{signal:data_tools.signal.gauss_noise}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{data\_tools.signal.}}\sphinxbfcode{\sphinxupquote{gauss\_noise}}}{\emph{x}, \emph{sd=1}}{}
Applies additive Gaussian (white) noise to a given signal.
\begin{itemize}
\item {} \begin{description}
\item[{Arguments;}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{x} {[}numpy.ndarray{]}: The signal, can have any number of
dimensions.

\item {} 
\sphinxstyleemphasis{sd} {[}float{]}: Optional, \sphinxcode{\sphinxupquote{1}} by default. The standard
deviation of the noise to apply.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Returns:}] \leavevmode\begin{itemize}
\item {} 
{[}numpy.ndarray{]}: The signal \sphinxstyleemphasis{x} with the additive Gaussian
noise applied.

\end{itemize}

\end{description}

\end{itemize}

\end{fulllineitems}

\phantomsection\label{\detokenize{spatial:module-data_tools.spatial}}\index{data\_tools.spatial (module)@\spxentry{data\_tools.spatial}\spxextra{module}}

\section{data\_tools.spatial}
\label{\detokenize{spatial:data-tools-spatial}}\label{\detokenize{spatial::doc}}
Spatial tools module.


\subsection{Contents}
\label{\detokenize{spatial:contents}}\index{equidist\_polar() (in module data\_tools.spatial)@\spxentry{equidist\_polar()}\spxextra{in module data\_tools.spatial}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spatial:data_tools.spatial.equidist_polar}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{data\_tools.spatial.}}\sphinxbfcode{\sphinxupquote{equidist\_polar}}}{\emph{n}, \emph{r=1}}{}
For a given number of points (and optionally radius), returns the
Cartesian coordinates of such number of equidistant points (in polar
coordinates). This is, the (x, y) coordinates of \sphinxstyleemphasis{n} points equally
spaced in a circle of radius \sphinxstyleemphasis{r}.
\begin{itemize}
\item {} \begin{description}
\item[{Arguments:}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{n} {[}int{]}: Number of points to retrieve the coordinates.

\item {} 
\sphinxstyleemphasis{r} {[}float{]}: Optional, \sphinxcode{\sphinxupquote{1}} by default. The radius of the
polar coordinates.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Returns:}] \leavevmode\begin{itemize}
\item {} 
{[}list{]}: Contains \sphinxstyleemphasis{n} {[}tuple{]} pairs containing the (x, y)
Cartesian coordinates.

\end{itemize}

\end{description}

\end{itemize}

\end{fulllineitems}

\index{get\_boundaries() (in module data\_tools.spatial)@\spxentry{get\_boundaries()}\spxextra{in module data\_tools.spatial}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spatial:data_tools.spatial.get_boundaries}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{data\_tools.spatial.}}\sphinxbfcode{\sphinxupquote{get\_boundaries}}}{\emph{x}, \emph{counts=False}}{}
Given an array, returns either the mask where the boundary edges are
or their counts if specified.
\begin{itemize}
\item {} \begin{description}
\item[{Arguments:}] \leavevmode\begin{itemize}
\item {} 
x {[}numpy.ndarray{]}: The array where boundaries are to be
identified or counted. Data type of its elements is totally
irrelevant.

\item {} 
count {[}bool{]}: Optional, \sphinxcode{\sphinxupquote{False}} by default. Whether to
return the number of boundary edges or just their mask.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Returns:}] \leavevmode\begin{itemize}
\item {} 
{[}numpy.ndarray{]}: Same shape as \sphinxstyleemphasis{x}. If \sphinxcode{\sphinxupquote{counts=False}},
contains \sphinxcode{\sphinxupquote{True}} on any cell that is on the boundary,
\sphinxcode{\sphinxupquote{False}} otherwise. If \sphinxcode{\sphinxupquote{counts=True}}, will return a
similar array but instead of {[}bool{]}, there will be {[}int{]}
denoting the number of boundary edges of the cells.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Examples:}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{=} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{get\PYGZus{}boundaries}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
\PYG{g+go}{array([[[ True,  True,  True],}
\PYG{g+go}{        [ True,  True,  True],}
\PYG{g+go}{        [ True,  True,  True]],}
\PYG{g+go}{       [[ True,  True,  True],}
\PYG{g+go}{        [ True, False,  True],}
\PYG{g+go}{        [ True,  True,  True]],}
\PYG{g+go}{       [[ True,  True,  True],}
\PYG{g+go}{        [ True,  True,  True],}
\PYG{g+go}{        [ True,  True,  True]]])}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{get\PYGZus{}boundaries}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{counts}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{g+go}{array([[[3, 2, 3],}
\PYG{g+go}{        [2, 1, 2],}
\PYG{g+go}{        [3, 2, 3]],}
\PYG{g+go}{       [[2, 1, 2],}
\PYG{g+go}{        [1, 0, 1],}
\PYG{g+go}{        [2, 1, 2]],}
\PYG{g+go}{       [[3, 2, 3],}
\PYG{g+go}{        [2, 1, 2],}
\PYG{g+go}{        [3, 2, 3]]])}
\end{sphinxVerbatim}

\end{description}

\end{itemize}

\end{fulllineitems}

\index{neighbour\_count() (in module data\_tools.spatial)@\spxentry{neighbour\_count()}\spxextra{in module data\_tools.spatial}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spatial:data_tools.spatial.neighbour_count}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{data\_tools.spatial.}}\sphinxbfcode{\sphinxupquote{neighbour\_count}}}{\emph{x}}{}
Given an array (up to three dimensions), returns another array with
the same shape containing the counts of cells’ neighbours whose
value is zero.
\begin{itemize}
\item {} \begin{description}
\item[{Arguments:}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{x} {[}numpy.ndarray{]}: The array where to count the neighbours
(zero-valued cells). Note that the cells can have any value
or data type. As long as they be converted to {[}bool{]}, the
function will count all \sphinxcode{\sphinxupquote{False}} around all \sphinxcode{\sphinxupquote{True}} cells.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Returns:}] \leavevmode\begin{itemize}
\item {} 
{[}numpy.ndarray{]}: Array with same shape as \sphinxstyleemphasis{x} containing the
neighbour count.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Examples:}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{=} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{randint}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{size}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x}
\PYG{g+go}{array([[0, 0, 1, 1, 0],}
\PYG{g+go}{       [0, 0, 0, 1, 1],}
\PYG{g+go}{       [1, 0, 1, 1, 1],}
\PYG{g+go}{       [0, 0, 0, 0, 0],}
\PYG{g+go}{       [1, 0, 0, 1, 1]])}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{neighbour\PYGZus{}count}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
\PYG{g+go}{array([[0, 0, 2, 1, 0],}
\PYG{g+go}{       [0, 0, 0, 1, 1],}
\PYG{g+go}{       [3, 0, 3, 1, 1],}
\PYG{g+go}{       [0, 0, 0, 0, 0],}
\PYG{g+go}{       [2, 0, 0, 2, 1]])}
\end{sphinxVerbatim}

\end{description}

\end{itemize}

\end{fulllineitems}

\phantomsection\label{\detokenize{strings:module-data_tools.strings}}\index{data\_tools.strings (module)@\spxentry{data\_tools.strings}\spxextra{module}}

\section{data\_tools.strings}
\label{\detokenize{strings:data-tools-strings}}\label{\detokenize{strings::doc}}
String operations module.


\subsection{Contents}
\label{\detokenize{strings:contents}}\index{is\_numeric() (in module data\_tools.strings)@\spxentry{is\_numeric()}\spxextra{in module data\_tools.strings}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{strings:data_tools.strings.is_numeric}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{data\_tools.strings.}}\sphinxbfcode{\sphinxupquote{is\_numeric}}}{\emph{s}}{}
Determines if a string can be considered a numeric value. NaN is
also considered, since it is float type.
\begin{itemize}
\item {} \begin{description}
\item[{Arguments:}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{s} {[}str{]}: String to be evaluated.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Returns:}] \leavevmode\begin{itemize}
\item {} 
{[}bool{]}: \sphinxcode{\sphinxupquote{True}}/\sphinxcode{\sphinxupquote{False}} depending if the condition is
satisfied.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Examples:}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{is\PYGZus{}numeric}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{True}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{is\PYGZus{}numeric}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}3.2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{True}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{is\PYGZus{}numeric}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{number}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{False}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{is\PYGZus{}numeric}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{NaN}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{True}
\end{sphinxVerbatim}

\end{description}

\end{itemize}

\end{fulllineitems}

\index{join\_str\_lists() (in module data\_tools.strings)@\spxentry{join\_str\_lists()}\spxextra{in module data\_tools.strings}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{strings:data_tools.strings.join_str_lists}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{data\_tools.strings.}}\sphinxbfcode{\sphinxupquote{join\_str\_lists}}}{\emph{a}, \emph{b}, \emph{sep=''}}{}
Joins element-wise two lists (or any 1D iterable) of strings with a
given separator (if provided). Length of the input lists must be
equal.
\begin{itemize}
\item {} \begin{description}
\item[{Arguments:}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{a} {[}list{]}: Contains the first elements {[}str{]} of the joint
strings.

\item {} 
\sphinxstyleemphasis{b} {[}list{]}: Contains the second elements {[}str{]} of the joint
strings.

\item {} 
\sphinxstyleemphasis{sep} {[}str{]}: Optional \sphinxcode{\sphinxupquote{'{'}}} (non separated) by default.
Determines the separator between the joint strings.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Returns:}] \leavevmode\begin{itemize}
\item {} 
{[}list{]}: List of the joint strings.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Example:}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{b} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{join\PYGZus{}str\PYGZus{}lists}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{sep}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZus{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{[\PYGZsq{}a\PYGZus{}1\PYGZsq{}, \PYGZsq{}b\PYGZus{}2\PYGZsq{}]}
\end{sphinxVerbatim}

\end{description}

\end{itemize}

\end{fulllineitems}



\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{d}
\item\relax\sphinxstyleindexentry{data\_tools.databases}\sphinxstyleindexpageref{databases:\detokenize{module-data_tools.databases}}
\item\relax\sphinxstyleindexentry{data\_tools.diffusion}\sphinxstyleindexpageref{diffusion:\detokenize{module-data_tools.diffusion}}
\item\relax\sphinxstyleindexentry{data\_tools.iterables}\sphinxstyleindexpageref{iterables:\detokenize{module-data_tools.iterables}}
\item\relax\sphinxstyleindexentry{data\_tools.models}\sphinxstyleindexpageref{models:\detokenize{module-data_tools.models}}
\item\relax\sphinxstyleindexentry{data\_tools.plots}\sphinxstyleindexpageref{plots:\detokenize{module-data_tools.plots}}
\item\relax\sphinxstyleindexentry{data\_tools.signal}\sphinxstyleindexpageref{signal:\detokenize{module-data_tools.signal}}
\item\relax\sphinxstyleindexentry{data\_tools.spatial}\sphinxstyleindexpageref{spatial:\detokenize{module-data_tools.spatial}}
\item\relax\sphinxstyleindexentry{data\_tools.strings}\sphinxstyleindexpageref{strings:\detokenize{module-data_tools.strings}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}