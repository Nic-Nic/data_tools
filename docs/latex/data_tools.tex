%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
 \ifdefined\DeclareUnicodeCharacterAsOptional
  \DeclareUnicodeCharacter{"00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{"2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{"2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{"2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{"251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{"2572}{\textbackslash}
 \else
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{2572}{\textbackslash}
 \fi
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.}}
\addto\captionsenglish{\renewcommand{\tablename}{Table}}
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{4}
\setcounter{secnumdepth}{4}


\title{data\_tools Documentation}
\date{Jan 08, 2019}
\release{0.0.6}
\author{Nicolàs Palacio}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex

\begin{document}

\maketitle
\sphinxtableofcontents
\phantomsection\label{\detokenize{index::doc}}


Data tools: a collection of Python functions and classes designed to
make data scientists’ life easier.

Copyright (C) 2018 Nicolàs Palacio

Contact: \sphinxhref{mailto:nicolaspalacio91@gmail.com}{nicolaspalacio91@gmail.com}


\chapter{Disclaimer}
\label{\detokenize{index:disclaimer}}
This package is still under development and will be periodically updated
with new features. Contributions are very welcome (fork + pull request).
If you find any bug or suggestion for upgrades, please use the
\sphinxhref{https://github.com/Nic-Nic/data\_tools/issues}{issue system}.

GNU-GLPv3:
This program is free software: you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
Public License for more details.

A full copy of the GNU General Public License can be found on file
\sphinxhref{../../LICENSE.md}{LICENSE.md}. If not, see
\sphinxurl{http://www.gnu.org/licenses/}.


\chapter{Dependencies}
\label{\detokenize{index:dependencies}}\begin{itemize}
\item {} 
\sphinxhref{http://www.numpy.org/}{NumPy}

\item {} 
\sphinxhref{https://matplotlib.org/}{Matplotlib}

\item {} 
\sphinxhref{https://pandas.pydata.org/}{Pandas}

\item {} 
\sphinxhref{https://www.scipy.org/}{SciPy}

\item {} 
\sphinxhref{http://scikit-learn.org/stable/index.html}{Scikit-learn}

\end{itemize}


\chapter{Installation}
\label{\detokenize{index:installation}}
First download/clone \sphinxcode{\sphinxupquote{data\_tools}} from the
\sphinxhref{https://github.com/Nic-Nic/data\_tools.git}{GitHub repository}.
From the terminal:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
git clone https://github.com/Nic\PYGZhy{}Nic/data\PYGZus{}tools.git
\PYG{n+nb}{cd} data\PYGZus{}tools
\end{sphinxVerbatim}

Then you can install it by running \sphinxcode{\sphinxupquote{setup.py}} as follows:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
python setup.py sdist
\end{sphinxVerbatim}

Or using \sphinxcode{\sphinxupquote{pip}}:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
pip install .
\end{sphinxVerbatim}

Along with \sphinxcode{\sphinxupquote{data\_tools}}, all dependencies will be installed as well as
the testing suite. In order to run the tests, type on the terminal:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
python \PYGZhy{}m test\PYGZus{}data\PYGZus{}tools
\end{sphinxVerbatim}

\sphinxstylestrong{NOTE:} \sphinxcode{\sphinxupquote{data\_tools.plots}} module does not have any tests
implemented.


\chapter{Modules}
\label{\detokenize{index:modules}}\phantomsection\label{\detokenize{databases:module-data_tools.databases}}\index{data\_tools.databases (module)}

\section{data\_tools.databases}
\label{\detokenize{databases:data-tools-databases}}\label{\detokenize{databases::doc}}
Databases functions module.
\index{kegg\_link() (in module data\_tools.databases)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{databases:data_tools.databases.kegg_link}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{data\_tools.databases.}}\sphinxbfcode{\sphinxupquote{kegg\_link}}}{\emph{query}, \emph{target='pathway'}}{}
Queries a request to the KEGG database to find related entries using
cross-references. A list of available database(s) and query examples
can be found in \sphinxurl{https://www.kegg.jp/kegg/rest/keggapi.html\#link}.
\begin{itemize}
\item {} \begin{description}
\item[{Arguments:}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{query} {[}list{]}: Or any iterable type containing the
identifier(s) to be queried as {[}str{]}. These can be either
valid database identifiers or databases \sphinxstyleemphasis{per se} (see the link
above).

\item {} 
\sphinxstyleemphasis{target} {[}str{]}: Optional, \sphinxcode{\sphinxupquote{'pathway'}} by default. Targeted
database to which the query should be linked to. You can check
other options available in the URL above.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Returns:}] \leavevmode\begin{itemize}
\item {} 
{[}pandas.DataFrame{]}: Two-column table containing both the
input query identifiers and their linked ones.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Example:}] \leavevmode
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{my\PYGZus{}query} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{hsa:10458}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ece:Z5100}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{kegg\PYGZus{}link}\PYG{p}{(}\PYG{n}{my\PYGZus{}query}\PYG{p}{)}
\PYG{g+go}{   query        pathway}
\PYG{g+go}{0  hsa:10458  path:hsa04520}
\PYG{g+go}{1  hsa:10458  path:hsa04810}
\PYG{g+go}{2  ece:Z5100  path:ece05130}
\end{sphinxVerbatim}

\end{description}

\end{itemize}

\end{fulllineitems}

\index{kegg\_pathway\_mapping() (in module data\_tools.databases)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{databases:data_tools.databases.kegg_pathway_mapping}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{data\_tools.databases.}}\sphinxbfcode{\sphinxupquote{kegg\_pathway\_mapping}}}{\emph{df}, \emph{mapid}, \emph{filename=None}}{}
Makes a request to KEGG pathway mapping tool according to a given
pathway ID (see \sphinxurl{https://www.kegg.jp/kegg/tool/map\_pathway2.html} for
more information). The user must provide a query of IDs to be mapped
with their corresponding background colors (and optionally also
foreground colors). The result is downloaded in the current
directory or a user-specified path.
\begin{itemize}
\item {} \begin{description}
\item[{Arguments:}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{df} {[}pandas.DataFrame{]}: Dataframe containing KEGG valid IDs
in the first column and corresponding background colors (e.g.:
red, blue, …). Optionally, a third column with the
foreground (font) colors can also be provided (black by
default). \sphinxstylestrong{NOTE:} hexadecimal codes for colors is also
supported. Index and column names of dataframe are ignored.

\item {} 
\sphinxstyleemphasis{mapid} {[}str{]}: A valid KEGG pathway ID. It can be a general
(e.g.: “mapXXXXX”) or organism-specific ID (e.g.: “hsaXXXXX”).

\item {} 
\sphinxstyleemphasis{filename} {[}str{]}: Optional, \sphinxcode{\sphinxupquote{None}} by default. This is, the
image will be stored in the current directory with the \sphinxstyleemphasis{mapid}
provided as file name. If provided, the image will be stored
within the specified path/file name.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Example:}] \leavevmode
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{my\PYGZus{}query} \PYG{o}{=} \PYG{n}{pandas}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1956}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{red}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsh{}f1f1f1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}
\PYG{g+gp}{... }                             \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{3845}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{blue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsh{}f1f1f1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}
\PYG{g+gp}{... }                             \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{5594}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{green}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{black}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{kegg\PYGZus{}pathway\PYGZus{}mapping}\PYG{p}{(}\PYG{n}{my\PYGZus{}query}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{hsa04010}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent{\hspace*{\fill}\sphinxincludegraphics{{hsa04010}.png}\hspace*{\fill}}

\end{description}

\end{itemize}

\end{fulllineitems}

\index{op\_kinase\_substrate() (in module data\_tools.databases)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{databases:data_tools.databases.op_kinase_substrate}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{data\_tools.databases.}}\sphinxbfcode{\sphinxupquote{op\_kinase\_substrate}}}{\emph{organism='9606'}, \emph{incl\_phosphatases=False}}{}
Queries OmniPath to retrieve the kinase-substrate interactions for a
given organism.
\begin{itemize}
\item {} \begin{description}
\item[{Arguments:}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{organism} {[}str{]}: Optional, \sphinxcode{\sphinxupquote{'9606'}} by default (Homo
sapiens). NCBI taxonomic identifier for the organism of
interest.

\item {} 
\sphinxstyleemphasis{incl\_phosphatases} {[}bool{]}: Optional \sphinxcode{\sphinxupquote{False}} by default.
Determines wether to include dephosphorylation interactions or
not.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Returns:}] \leavevmode\begin{itemize}
\item {} 
{[}pandas.DataFrame{]}: Table containing the enzyme-substrate
(kinase/phosphatase-target) network of each phospho-site.

\end{itemize}

\end{description}

\end{itemize}

\end{fulllineitems}

\index{up\_map() (in module data\_tools.databases)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{databases:data_tools.databases.up_map}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{data\_tools.databases.}}\sphinxbfcode{\sphinxupquote{up\_map}}}{\emph{query}, \emph{source='ACC'}, \emph{target='GENENAME'}}{}
Queries a request to UniProt.org in order to map a given list of
identifiers. You can check the options available of input/output
identifiers at \sphinxurl{https://www.uniprot.org/help/api\_idmapping}.
\begin{itemize}
\item {} \begin{description}
\item[{Arguments:}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{query} {[}list{]}: Or any iterable type containing the
identifiers to be queried as {[}str{]}.

\item {} 
\sphinxstyleemphasis{source} {[}str{]}: Optional, \sphinxcode{\sphinxupquote{'ACC'}} by default. This is,
UniProt accesion number. You can check other options available
in the URL above.

\item {} 
\sphinxstyleemphasis{target} {[}str{]}: Optional, \sphinxcode{\sphinxupquote{'GENENAME'}} by default. You can
check other options available in the URL above.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Returns:}] \leavevmode\begin{itemize}
\item {} 
{[}pandas.DataFrame{]}: Two-column table containing both the
inputed identifiers and the mapping result of these. \sphinxstylestrong{NOTE:}
The returned table may not have the same order as in
\sphinxcode{\sphinxupquote{query}}. Also, if some ID could not be mapped, the size of
the returned table will differ from the length of \sphinxcode{\sphinxupquote{query}}.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Examples:}] \leavevmode
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{my\PYGZus{}query} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{P00533}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{P31749}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{P16220}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{up\PYGZus{}map}\PYG{p}{(}\PYG{n}{my\PYGZus{}query}\PYG{p}{)}
\PYG{g+go}{      ACC GENENAME}
\PYG{g+go}{0  P00533     EGFR}
\PYG{g+go}{1  P31749     AKT1}
\PYG{g+go}{2  P16220    CREB1}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{up\PYGZus{}map}\PYG{p}{(}\PYG{n}{my\PYGZus{}query}\PYG{p}{,} \PYG{n}{target}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{KEGG\PYGZus{}ID}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{      ACC   KEGG\PYGZus{}ID}
\PYG{g+go}{0  P00533  hsa:1956}
\PYG{g+go}{2  P16220  hsa:1385}
\PYG{g+go}{1  P31749   hsa:207}
\end{sphinxVerbatim}

\end{description}

\end{itemize}

\end{fulllineitems}

\phantomsection\label{\detokenize{diffusion:module-data_tools.diffusion}}\index{data\_tools.diffusion (module)}

\section{data\_tools.diffusion}
\label{\detokenize{diffusion:data-tools-diffusion}}\label{\detokenize{diffusion::doc}}
Diffusion solvers module.

The following functions provide tools to compute the diffusion on one or
two dimensions with different explicit or implicit methods.

\sphinxstylestrong{NOTE:} Explicit methods (\sphinxcode{\sphinxupquote{'euler\_explicit1D'}} and
\sphinxcode{\sphinxupquote{'euler\_explicit2D'}}) are conditionally stable. This means that in
order to keep numerical stability of the solution (and obtain an
accurate result), these methods need to fulfill the
Courant\textendash{}Friedrichs\textendash{}Lewy (CFL) condition. For the one-dimensional case:
\begin{equation*}
\begin{split}D\frac{\Delta t}{\Delta x^2}\leq\frac{1}{2}\end{split}
\end{equation*}
For the two-dimensional case (and assuming \(\Delta x=\Delta y\)):
\begin{equation*}
\begin{split}D\frac{\Delta t}{\Delta x^2}\leq\frac{1}{4}\end{split}
\end{equation*}
The implicit methods are (theoretically) unconditionally stable, hence
are more permissive in terms of discretization step-size.

Currently for the implicit methods only the coefficient matrix
contruction is available. To solve the diffusion problem user can use
any of the available linear algebra solvers by providing the current
diffusing field state and the matrix on each time-step.
\begin{itemize}
\item {} 
Simplest options are either \sphinxcode{\sphinxupquote{numpy.linalg.solve()}} or
\sphinxcode{\sphinxupquote{scipy.linalg.solve()}} (both not very fast).

\item {} 
If the coefficient matrix is positive-definite (it is most of the
times, but can be double-checked, specially if errors arise) and
symmetric, a good option is Choleski’s factorization. This is already
implemented in \sphinxcode{\sphinxupquote{scipy.linalg.cholesky()}} which factorizes the
coefficient matrix and that can be passed to the
\sphinxcode{\sphinxupquote{scipy.linalg.cho\_solve()}} which is way faster than the option above.

\item {} 
Another option (but don’t tell anyone) is to invert the coefficient
matrix and just solve the equation with a matrix multiplication. This
is way faster but your coefficient matrix has to be invertible. If
the determinant is close to zero, may cause numerical instability.

\end{itemize}
\index{euler\_explicit1D() (in module data\_tools.diffusion)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{diffusion:data_tools.diffusion.euler_explicit1D}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{data\_tools.diffusion.}}\sphinxbfcode{\sphinxupquote{euler\_explicit1D}}}{\emph{x0}, \emph{dt}, \emph{dx2}, \emph{d=1}, \emph{bcs='periodic'}}{}
Computes diffusion on a 1D space over a time-step using Euler
explicit method.
\begin{itemize}
\item {} \begin{description}
\item[{Arguments:}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{x0} {[}numpy.ndarray{]}: Initial state of a 1D array from which
the difusion is to be computed.

\item {} 
\sphinxstyleemphasis{dt} {[}float{]}: Discretization time-step.

\item {} 
\sphinxstyleemphasis{dx2} {[}float{]}: Discretization spatial-step (squared).

\item {} 
\sphinxstyleemphasis{d} {[}float{]}: Optional, \sphinxcode{\sphinxupquote{1}} by default. The diffusion
coefficient.

\item {} 
\sphinxstyleemphasis{bcs} {[}str{]}: Optional, \sphinxcode{\sphinxupquote{'periodic'}} by default. Determines
the boundary conditions. Available options are \sphinxcode{\sphinxupquote{'periodic'}},
\sphinxcode{\sphinxupquote{'dirichlet'{'}}} or \sphinxcode{\sphinxupquote{'neumann'}}. Note that Dirichlet BCs do
not hold mass conservation.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Returns:}] \leavevmode\begin{itemize}
\item {} 
{[}numpy.ndarray{]}: Computed state array (1D) after one time-step
according to the parameters and conditions selected.

\end{itemize}

\end{description}

\end{itemize}

\end{fulllineitems}

\index{euler\_explicit2D() (in module data\_tools.diffusion)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{diffusion:data_tools.diffusion.euler_explicit2D}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{data\_tools.diffusion.}}\sphinxbfcode{\sphinxupquote{euler\_explicit2D}}}{\emph{x0}, \emph{dt}, \emph{dx2}, \emph{d=1}, \emph{bcs='periodic'}}{}
Computes diffusion on a 2D space over a time-step using Euler
explicit method.
\begin{itemize}
\item {} \begin{description}
\item[{Arguments:}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{x0} {[}numpy.ndarray{]}: Initial state of a 2D array from which
the difusion is to be computed.

\item {} 
\sphinxstyleemphasis{dt} {[}float{]}: Discretization time-step.

\item {} 
\sphinxstyleemphasis{dx2} {[}float{]}: Discretization spatial-step (squared). It is
assumed that is the same in both dimensions (dx = dy).

\item {} 
\sphinxstyleemphasis{d} {[}float{]}: Optional, \sphinxcode{\sphinxupquote{1}} by default. The diffusion
coefficient.

\item {} 
\sphinxstyleemphasis{bcs} {[}str{]}: Optional, \sphinxcode{\sphinxupquote{'periodic'}} by default. Determines
the boundary conditions. Available options are \sphinxcode{\sphinxupquote{'periodic'}},
\sphinxcode{\sphinxupquote{'dirichlet'{'}}} or \sphinxcode{\sphinxupquote{'neumann'}}. Note that Dirichlet BCs do
not hold mass conservation.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Returns:}] \leavevmode\begin{itemize}
\item {} 
{[}numpy.ndarray{]}: Computed state array (2D) after one time-step
according to the parameters and conditions selected.

\end{itemize}

\end{description}

\end{itemize}

\end{fulllineitems}

\index{euler\_implicit\_coef\_mat() (in module data\_tools.diffusion)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{diffusion:data_tools.diffusion.euler_implicit_coef_mat}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{data\_tools.diffusion.}}\sphinxbfcode{\sphinxupquote{euler\_implicit\_coef\_mat}}}{\emph{dx2}, \emph{dt}, \emph{nx}, \emph{ny=None}, \emph{d=1}, \emph{bcs='periodic'}}{}
Computes the coefficient matrix to solve the diffusion problem with
the Euler implicit method such that:
\begin{equation*}
\begin{split}\mathbf{A}\cdot u^{n+1}=u^{n}\end{split}
\end{equation*}
Where \sphinxstylestrong{A} is the coefficient matrix and \sphinxstyleemphasis{u} the diffusing field.
Note that for a 2D space, it is considered that \sphinxstyleemphasis{u} has been
vectorized beforehand (e.g.: \sphinxtitleref{u.reshape(-1)} assuming \sphinxtitleref{u} is a 2D
{[}\sphinxtitleref{numpy.array}{]}).
\begin{itemize}
\item {} \begin{description}
\item[{Arguments:}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{dx2} {[}float{]}: Discretization spatial-step (squared). It is
assumed that is the same in both dimensions (dx = dy).

\item {} 
\sphinxstyleemphasis{dt} {[}float{]}: Discretization time-step.

\item {} 
\sphinxstyleemphasis{nx} {[}int{]}: The number of discrete steps in the first spatial
dimension.

\item {} 
\sphinxstyleemphasis{ny} {[}int{]}: Optional, \sphinxcode{\sphinxupquote{None}} by default. The number of
discrete steps in the second spatial dimension (if any).

\item {} 
\sphinxstyleemphasis{d} {[}float{]}: Optional, \sphinxcode{\sphinxupquote{1}} by default. The diffusion
coefficient.

\item {} 
\sphinxstyleemphasis{bcs} {[}str{]}: Optional, \sphinxcode{\sphinxupquote{'periodic'}} by default. Determines
the boundary conditions. Available options are \sphinxcode{\sphinxupquote{'periodic'}},
\sphinxcode{\sphinxupquote{'dirichlet'{'}}} or \sphinxcode{\sphinxupquote{'neumann'}}. Note that Dirichlet BCs do
not hold mass conservation.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Returns:}] \leavevmode\begin{itemize}
\item {} 
{[}numpy.ndarray{]}: The coefficient matrix. Shape is \sphinxtitleref{{[}nx, nx{]}}
for one-dimensional problem and \sphinxtitleref{{[}nx*ny, nx*ny{]}} for the
two-dimensional case.

\end{itemize}

\end{description}

\end{itemize}

\end{fulllineitems}

\index{crank\_nicolson\_coef\_mats() (in module data\_tools.diffusion)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{diffusion:data_tools.diffusion.crank_nicolson_coef_mats}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{data\_tools.diffusion.}}\sphinxbfcode{\sphinxupquote{crank\_nicolson\_coef\_mats}}}{\emph{dx2}, \emph{dt}, \emph{nx}, \emph{ny=None}, \emph{d=1}, \emph{bcs='periodic'}}{}
Computes the coefficient matrices to solve the diffusion problem
with the Crank-Nicolson method such that:
\begin{equation*}
\begin{split}\mathbf{B}\cdot u^{n+1}=\mathbf{D}\cdot u^{n}\end{split}
\end{equation*}
Where \sphinxstylestrong{B} and \sphinxstylestrong{D} are the coefficient matrices and \sphinxstyleemphasis{u} the
diffusing field. Note that for a 2D space, it is considered that \sphinxstyleemphasis{u}
has been vectorized beforehand (e.g.: \sphinxtitleref{u.reshape(-1)} assuming \sphinxtitleref{u}
is a 2D {[}\sphinxtitleref{numpy.array}{]}).
\begin{itemize}
\item {} \begin{description}
\item[{Arguments:}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{dx2} {[}float{]}: Discretization spatial-step (squared). It is
assumed that is the same in both dimensions (dx = dy).

\item {} 
\sphinxstyleemphasis{dt} {[}float{]}: Discretization time-step.

\item {} 
\sphinxstyleemphasis{nx} {[}int{]}: The number of discrete steps in the first spatial
dimension.

\item {} 
\sphinxstyleemphasis{ny} {[}int{]}: Optional, \sphinxcode{\sphinxupquote{None}} by default. The number of
discrete steps in the second spatial dimension (if any).

\item {} 
\sphinxstyleemphasis{d} {[}float{]}: Optional, \sphinxcode{\sphinxupquote{1}} by default. The diffusion
coefficient.

\item {} 
\sphinxstyleemphasis{bcs} {[}str{]}: Optional, \sphinxcode{\sphinxupquote{'periodic'}} by default. Determines
the boundary conditions. Available options are \sphinxcode{\sphinxupquote{'periodic'}},
\sphinxcode{\sphinxupquote{'dirichlet'{'}}} or \sphinxcode{\sphinxupquote{'neumann'}}. Note that Dirichlet BCs do
not hold mass conservation.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Returns:}] \leavevmode\begin{itemize}
\item {} 
{[}numpy.ndarray{]}: The coefficient matrix \sphinxstylestrong{B}. Shape is
\sphinxtitleref{{[}nx, nx{]}} for one-dimensional problem and \sphinxtitleref{{[}nx*ny, nx*ny{]}}
for the two-dimensional case.

\item {} 
{[}numpy.ndarray{]}: The coefficient matrix \sphinxstylestrong{D}. Shape is the
same as \sphinxstylestrong{B}.

\end{itemize}

\end{description}

\end{itemize}

\end{fulllineitems}

\index{build\_coef\_mat() (in module data\_tools.diffusion)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{diffusion:data_tools.diffusion.build_coef_mat}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{data\_tools.diffusion.}}\sphinxbfcode{\sphinxupquote{build\_coef\_mat}}}{\emph{a}, \emph{b}, \emph{nx}, \emph{ny=None}, \emph{bcs='periodic'}}{}
Builds a coefficient matrix according to the central and neighbor
coefficients, system size and boundary conditions.
\begin{itemize}
\item {} \begin{description}
\item[{Arguments:}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{a} {[}float{]}: The central element coefficient.

\item {} 
\sphinxstyleemphasis{b} {[}float{]}: The neighbor element coefficient.

\item {} 
\sphinxstyleemphasis{nx} {[}int{]}: The number of discrete steps in the first spatial
dimension.

\item {} 
\sphinxstyleemphasis{ny} {[}int{]}: Optional, \sphinxcode{\sphinxupquote{None}} by default. The number of
discrete steps in the second spatial dimension (if any).

\item {} 
\sphinxstyleemphasis{bcs} {[}str{]}: Optional, \sphinxcode{\sphinxupquote{'periodic'}} by default. Determines
the boundary conditions. Available options are \sphinxcode{\sphinxupquote{'periodic'}},
\sphinxcode{\sphinxupquote{'dirichlet'{'}}} or \sphinxcode{\sphinxupquote{'neumann'}}. Note that Dirichlet BCs do
not hold mass conservation.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Returns:}] \leavevmode\begin{itemize}
\item {} 
{[}numpy.ndarray{]}: The coefficient matrix. Shape is \sphinxtitleref{{[}nx, nx{]}}
for one-dimensional problem and \sphinxtitleref{{[}nx*ny, nx*ny{]}} for the
two-dimensional case.

\end{itemize}

\end{description}

\end{itemize}

\end{fulllineitems}

\phantomsection\label{\detokenize{iterables:module-data_tools.iterables}}\index{data\_tools.iterables (module)}

\section{data\_tools.iterables}
\label{\detokenize{iterables:data-tools-iterables}}\label{\detokenize{iterables::doc}}
Iterable-type operations module.
\index{bit\_or() (in module data\_tools.iterables)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{iterables:data_tools.iterables.bit_or}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{data\_tools.iterables.}}\sphinxbfcode{\sphinxupquote{bit\_or}}}{\emph{a}, \emph{b}}{}
Returns the bit operation OR between two bit-strings \sphinxstyleemphasis{a} and \sphinxstyleemphasis{b}.
\sphinxstylestrong{NOTE:} \sphinxstyleemphasis{a} and \sphinxstyleemphasis{b} must have the same size.
\begin{itemize}
\item {} \begin{description}
\item[{Arguments:}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{a} {[}tuple{]}: Or any iterable type.

\item {} 
\sphinxstyleemphasis{b} {[}tuple{]}: Or any iterable type.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Returns:}] \leavevmode\begin{itemize}
\item {} 
{[}tuple{]}: OR operation between \sphinxstyleemphasis{a} and \sphinxstyleemphasis{b} element-wise.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Examples:}] \leavevmode
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{bit\PYGZus{}or}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\PYG{g+go}{(1, 0, 1)}
\end{sphinxVerbatim}

\end{description}

\end{itemize}

\end{fulllineitems}

\index{chunk\_this() (in module data\_tools.iterables)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{iterables:data_tools.iterables.chunk_this}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{data\_tools.iterables.}}\sphinxbfcode{\sphinxupquote{chunk\_this}}}{\emph{L}, \emph{n}}{}
For a given list \sphinxstyleemphasis{L}, returns another list of \sphinxstyleemphasis{n}-sized chunks from
it (in the same order).
\begin{itemize}
\item {} \begin{description}
\item[{Arguments:}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{L} {[}list{]}: The list to be sliced into sublists of the
definded size.

\item {} 
\sphinxstyleemphasis{n} {[}int{]}: The size of the chunks.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Returns:}] \leavevmode\begin{itemize}
\item {} 
{[}list{]}: List of \sphinxstyleemphasis{n}-sized chunks from \sphinxstyleemphasis{L}. \sphinxstylestrong{NOTE:} If the
number of items in \sphinxstyleemphasis{L} is not divisible by \sphinxstyleemphasis{n}, the last
element returned will have an inferior size.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Examples:}] \leavevmode
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L} \PYG{o}{=} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{chunk\PYGZus{}this}\PYG{p}{(}\PYG{n}{L}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+go}{[[0, 1], [2, 3], [4, 5]]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{chunk\PYGZus{}this}\PYG{p}{(}\PYG{n}{L}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{g+go}{[[0, 1, 2, 3], [4, 5]]}
\end{sphinxVerbatim}

\end{description}

\end{itemize}

\end{fulllineitems}

\index{find\_min() (in module data\_tools.iterables)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{iterables:data_tools.iterables.find_min}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{data\_tools.iterables.}}\sphinxbfcode{\sphinxupquote{find\_min}}}{\emph{A}}{}
Finds and returns the subset of vectors whose sum is minimum from a
given set \sphinxstyleemphasis{A}.
\begin{itemize}
\item {} \begin{description}
\item[{Arguments:}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{A} {[}set{]}: Set of vectors ({[}tuple{]} or any iterable).

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Returns:}] \leavevmode\begin{itemize}
\item {} 
{[}set{]}: Subset of vectors in \sphinxstyleemphasis{A} whose sum is minimum.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Examples:}] \leavevmode
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{A} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{find\PYGZus{}min}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}
\PYG{g+go}{set([(0, 1, 0), (1, 0, 0)])}
\end{sphinxVerbatim}

\end{description}

\end{itemize}

\end{fulllineitems}

\index{in\_all() (in module data\_tools.iterables)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{iterables:data_tools.iterables.in_all}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{data\_tools.iterables.}}\sphinxbfcode{\sphinxupquote{in\_all}}}{\emph{x}, \emph{N}}{}
Checks if a element \sphinxstyleemphasis{x} is present in all collections contained in a
list \sphinxstyleemphasis{N}.
\begin{itemize}
\item {} \begin{description}
\item[{Arguments:}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{x} {[}object{]}: Any type of object, it is assumed to be the same
type as the objects contained in the elements of \sphinxstyleemphasis{N}.

\item {} 
\sphinxstyleemphasis{N} {[}list{]}: Or any iterable type containing a collection of
other iterables containing the objects.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Returns:}] \leavevmode\begin{itemize}
\item {} 
{[}bool{]}: \sphinxcode{\sphinxupquote{True}} if \sphinxstyleemphasis{x} is found in all elements of \sphinxstyleemphasis{N},
\sphinxcode{\sphinxupquote{False}} otherwise.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Examples:}] \leavevmode
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{N} \PYG{o}{=} \PYG{p}{[}\PYG{p}{\PYGZob{}}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{c+c1}{\PYGZsh{} \PYGZlt{}\PYGZhy{} set A}
\PYG{g+gp}{... }     \PYG{p}{\PYGZob{}}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZcb{}}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{} \PYGZlt{}\PYGZhy{} set B}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{in\PYGZus{}all}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{N}\PYG{p}{)}
\PYG{g+go}{True}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{y} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{in\PYGZus{}all}\PYG{p}{(}\PYG{n}{y}\PYG{p}{,} \PYG{n}{N}\PYG{p}{)}
\PYG{g+go}{False}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{N} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Hello}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{world}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{!}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}
\PYG{g+gp}{... }     \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Hello}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{user}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Hello}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{in\PYGZus{}all}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{N}\PYG{p}{)}
\PYG{g+go}{True}
\end{sphinxVerbatim}

\end{description}

\end{itemize}

\end{fulllineitems}

\index{subsets() (in module data\_tools.iterables)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{iterables:data_tools.iterables.subsets}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{data\_tools.iterables.}}\sphinxbfcode{\sphinxupquote{subsets}}}{\emph{N}}{}
Function that computes all possible logical relations between all
sets on a list \sphinxstyleemphasis{N} and returns all subsets. This is, the subsets
that would represent each intersecting area on a Venn diagram.
\begin{itemize}
\item {} \begin{description}
\item[{Arguments:}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{N} {[}list{]}: Or any iterable type containing {[}set{]} objects.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Returns:}] \leavevmode\begin{itemize}
\item {} 
{[}dict{]}: Collection of subsets according to the logical
relations between the sets in \sphinxstyleemphasis{N}. The keys are binary codes
that denote the logical relation (see examples below).

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Examples:}] \leavevmode
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{N} \PYG{o}{=} \PYG{p}{[}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{\PYGZcb{}}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{subsets}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}
\PYG{g+go}{\PYGZob{}\PYGZsq{}11\PYGZsq{}: set([2]), \PYGZsq{}10\PYGZsq{}: set([0, 1]), \PYGZsq{}01\PYGZsq{}: set([3, 4])\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{N} \PYG{o}{=} \PYG{p}{[}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{\PYGZcb{}}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{subsets}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}
\PYG{g+go}{\PYGZob{}\PYGZsq{}010\PYGZsq{}: set([2]), \PYGZsq{}011\PYGZsq{}: set([3]), \PYGZsq{}001\PYGZsq{}: set([4]), \PYGZsq{}111\PYGZsq{}: set([}
\PYG{g+go}{]), \PYGZsq{}110\PYGZsq{}: set([]), \PYGZsq{}100\PYGZsq{}: set([0]), \PYGZsq{}101\PYGZsq{}: set([1])\PYGZcb{}}
\end{sphinxVerbatim}

\end{description}

\end{itemize}

\end{fulllineitems}

\index{unzip\_dicts() (in module data\_tools.iterables)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{iterables:data_tools.iterables.unzip_dicts}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{data\_tools.iterables.}}\sphinxbfcode{\sphinxupquote{unzip\_dicts}}}{\emph{*dicts}}{}
Unzips the keys and values for any number of dictionaries passed as
arguments (see below for examples).
\begin{itemize}
\item {} \begin{description}
\item[{Arguments:}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{*dicts} {[}dict{]}: Dictionaries from which key/value pairs are
to be unzipped.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Returns:}] \leavevmode\begin{itemize}
\item {} 
{[}list{]}: Two-element list contianing all keys and all values
respectively from the dictionaries in \sphinxstyleemphasis{*dicts}.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Example:}] \leavevmode
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{n+nb}{dict}\PYG{p}{(}\PYG{p}{[}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{x\PYGZus{}a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{y\PYGZus{}a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{b} \PYG{o}{=} \PYG{n+nb}{dict}\PYG{p}{(}\PYG{p}{[}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{x\PYGZus{}b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{y\PYGZus{}b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{unzip}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\PYG{g+go}{[(\PYGZsq{}y\PYGZus{}a\PYGZsq{}, \PYGZsq{}x\PYGZus{}a\PYGZsq{}, \PYGZsq{}x\PYGZus{}b\PYGZsq{}, \PYGZsq{}y\PYGZus{}b\PYGZsq{}), (3, 2, 1, \PYGZhy{}1)]}
\end{sphinxVerbatim}

\end{description}

\end{itemize}

\end{fulllineitems}

\phantomsection\label{\detokenize{models:module-data_tools.models}}\index{data\_tools.models (module)}

\section{data\_tools.models}
\label{\detokenize{models:data-tools-models}}\label{\detokenize{models::doc}}
Model classes module.
\index{DoseResponse (class in data\_tools.models)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{models:data_tools.models.DoseResponse}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{data\_tools.models.}}\sphinxbfcode{\sphinxupquote{DoseResponse}}}{\emph{d\_data, r\_data, x0=None, x\_scale=None, bounds=({[}0, 0, -inf{]}, {[}inf, inf, inf{]})}}{}
Wrapper class for \sphinxcode{\sphinxupquote{scipy.optimize.least\_squares}} to fit
dose-response curves on a pre-defined Hill function with the
following form:
\begin{equation*}
\begin{split}R=\frac{mD^n}{k^n+D^n}\end{split}
\end{equation*}
Where \(D\) is the dose, \(k\), \(m\) and \(n\) are
the parameters to be fitted.
\begin{itemize}
\item {} \begin{description}
\item[{Arguments:}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{d\_data} {[}numpy.ndarray{]}: Or any iterable (1D). Contains the
training data corresponding to the dose.

\item {} 
\sphinxstyleemphasis{r\_data} {[}numpy.ndarray{]}: Or any iterable (1D). Contains the
training data corresponding to the response.

\item {} 
\sphinxstyleemphasis{x0} {[}list{]}: Optional, \sphinxcode{\sphinxupquote{None}} by default. Or any
iterable of three elements. Contains the initial guess for the
parameters. Parameters are considered to be in alphabetical
order. This is, first element corresponds to \(k\), second
is \(m\) and last is \(n\). If \sphinxcode{\sphinxupquote{None}} (default), the
initial guess is inferred from \sphinxstyleemphasis{r\_data}.

\item {} 
\sphinxstyleemphasis{x\_scale} {[}list{]}: Optional, \sphinxcode{\sphinxupquote{None}} by default. Or any
iterable of three elements. Scale of each parameter. May
improve the fitting if the scaled parameters have similar
effect on the cost function. If \sphinxcode{\sphinxupquote{None}} (default), the scale
is inferred from \sphinxstyleemphasis{x0}.

\item {} 
\sphinxstyleemphasis{bounds} {[}tuple{]}: Optional \sphinxcode{\sphinxupquote{({[}0, 0, -inf{]}, {[}inf, inf, inf{]})}}
by default. Two-element tuple containing the lower and upper
boundaries for the parameters (elements of the tuple are
iterables of three elements each).

\end{itemize}

\end{description}

\end{itemize}
\begin{itemize}
\item {} \begin{description}
\item[{Attributes:}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{x0} {[}list{]}: Contains the initial guess for the parameters.
Parameters are considered to be in alphabetical order. This
is, first element corresponds to \(k\), second is
\(m\) and last is \(n\).

\item {} 
\sphinxstyleemphasis{x\_scale} {[}list{]}: Scale of each parameter.

\item {} 
\sphinxstyleemphasis{model} {[}scipy.optimize.OptimizeResult{]}: Contains the result
of the optimized model. See \sphinxhref{https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.OptimizeResult.html\#scipy.optimize.OptimizeResult}{SciPy’s reference} for more
information.

\item {} 
\sphinxstyleemphasis{params} {[}numpy.ndarray{]}: Three-element array containing the
fitted parameters \(k\), \(m\) and \(n\).

\end{itemize}

\end{description}

\end{itemize}
\index{ec() (data\_tools.models.DoseResponse method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{models:data_tools.models.DoseResponse.ec}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{ec}}}{\emph{p=50}}{}
Computes the effective concentration for the specified
percentage of maximal concentration (\(EC_{p}\)).
\begin{itemize}
\item {} \begin{description}
\item[{Arguments:}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{p} {[}int{]}: Optional, \sphinxcode{\sphinxupquote{50}} by default (\(EC_{50}\)).
Defines the percentage of the maximal from which the
effective concentration is to be computed.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Returns}] \leavevmode\begin{itemize}
\item {} 
{[}float{]}: Value of the \(EC_{p}\) computed according
to the model parameters.

\end{itemize}

\end{description}

\end{itemize}

\end{fulllineitems}

\index{plot() (data\_tools.models.DoseResponse method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{models:data_tools.models.DoseResponse.plot}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{plot}}}{\emph{title=None}, \emph{filename=None}, \emph{figsize=None}, \emph{legend=True}}{}
Plots the data points and the fitted function together.
\begin{itemize}
\item {} \begin{description}
\item[{Arguments:}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{title} {[}str{]}: Optional, \sphinxcode{\sphinxupquote{None}} by default. Defines the
plot title.

\item {} 
\sphinxstyleemphasis{filename} {[}str{]}: Optional, \sphinxcode{\sphinxupquote{None}} by default. If
passed, indicates the file name or path where to store the
figure. Format must be specified (e.g.: .png, .pdf, etc)

\item {} 
\sphinxstyleemphasis{figsize} {[}tuple{]}: Optional, \sphinxcode{\sphinxupquote{None}} by default (default
matplotlib size). Any iterable containing two values
denoting the figure size (in inches) as {[}width, height{]}.

\item {} 
\sphinxstyleemphasis{legend} {[}bool{]}: Optional, \sphinxcode{\sphinxupquote{True}} by default. Indicates
whether to show the plot legend or not.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Returns:}] \leavevmode\begin{itemize}
\item {} 
{[}matplotlib.figure.Figure{]}: Figure object showing the data
points and the fitted model function.

\end{itemize}

\end{description}

\end{itemize}

\end{fulllineitems}


\end{fulllineitems}

\index{Lasso (class in data\_tools.models)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{models:data_tools.models.Lasso}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{data\_tools.models.}}\sphinxbfcode{\sphinxupquote{Lasso}}}{\emph{Cs=500}, \emph{cv=10}, \emph{sampler='skf'}, \emph{solver='liblinear'}, \emph{**kwargs}}{}
Wrapper class inheriting from
\sphinxcode{\sphinxupquote{sklearn.linear\_model.LogisticRegressionCV}} with L1
regularization.
\begin{itemize}
\item {} \begin{description}
\item[{Arguments:}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{Cs} {[}int{]}: Optional, \sphinxcode{\sphinxupquote{500}} by default. Integer or list of
float values of regularization parameters to test. If an
integer is passed, it will determine the number of values
taken from a logarithmic scale between \sphinxcode{\sphinxupquote{1e-4}} and \sphinxcode{\sphinxupquote{1e4}}.
Note that the value of the parameter is defined as the inverse
of the regularization strength.

\item {} 
\sphinxstyleemphasis{cv} {[}int{]}: Optional, \sphinxcode{\sphinxupquote{10}} by default. Denotes the number of
cross validation (CV) folds.

\item {} 
\sphinxstyleemphasis{sampler} {[}str{]}: Optional, \sphinxcode{\sphinxupquote{'skf'}} by default. Determines
which sampling method is used to generate the test and
training sets for CV. Methods available are K-Fold (\sphinxcode{\sphinxupquote{'kf'}}),
Shuffle Split (\sphinxcode{\sphinxupquote{'ss'}}) and their stratified variants
(\sphinxcode{\sphinxupquote{'skf'}} and \sphinxcode{\sphinxupquote{'sss'}} respectively).

\item {} 
\sphinxstyleemphasis{solver} {[}str{]}: Optional, \sphinxcode{\sphinxupquote{'liblinear'}} by default.
Determines which solver algorithm to use. Note that L1
regularization can only be handled by \sphinxcode{\sphinxupquote{'liblinear'}} and
\sphinxcode{\sphinxupquote{'saga'}}. Additionally if the classification is multinomial,
only the latter option is available.

\item {} 
\sphinxstyleemphasis{**kwargs}: Optional. Any other keyword argument accepted by
the \sphinxcode{\sphinxupquote{sklearn.linear\_model.LogisticRegressionCV}} class.

\end{itemize}

Other keyword arguments and functions available from the parent
class \sphinxcode{\sphinxupquote{LogisticRegressionCV}} can be fount in \sphinxhref{http://scikit-learn.org/stable/modules/generated/sklearn.linear\_model.LogisticRegressionCV.html}{Scikit-Learn’s
reference}.

\end{description}

\end{itemize}
\index{fit\_data() (data\_tools.models.Lasso method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{models:data_tools.models.Lasso.fit_data}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{fit\_data}}}{\emph{x}, \emph{y}, \emph{silent=False}}{}
Fits the data to the logistic model.
\begin{itemize}
\item {} \begin{description}
\item[{Arguments:}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{x} {[}pandas.DataFrame{]}: Contains the values/measurements
{[}float{]} of the features (columns) for each
sample/replicate (rows).

\item {} 
\sphinxstyleemphasis{y} {[}pandas.Series{]}: List or any iterable containing the
observed class of each sample (must have the same order as
in \sphinxstyleemphasis{x}).

\item {} 
\sphinxstyleemphasis{silent} {[}bool{]}: Optional, \sphinxcode{\sphinxupquote{False}} by default.
Determines whether messages are printed or not.

\end{itemize}

\end{description}

\end{itemize}

\end{fulllineitems}

\index{plot\_coef() (data\_tools.models.Lasso method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{models:data_tools.models.Lasso.plot_coef}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{plot\_coef}}}{\emph{filename=None}, \emph{figsize=None}}{}
Plots the non-zero coefficients for the fitted predictor
features.
\begin{itemize}
\item {} \begin{description}
\item[{Arguments:}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{filename} {[}str{]}: Optional, \sphinxcode{\sphinxupquote{None}} by default. If
passed, indicates the file name or path where to store the
figure. Format must be specified (e.g.: .png, .pdf, etc)

\item {} 
\sphinxstyleemphasis{figsize} {[}tuple{]}: Optional, \sphinxcode{\sphinxupquote{None}} by default (default
matplotlib size). Any iterable containing two values
denoting the figure size (in inches) as {[}width, height{]}.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Returns:}] \leavevmode\begin{itemize}
\item {} 
{[}matplotlib.figure.Figure{]}: Figure object containing the
bar plot of the non-zero coefficients.

\end{itemize}

\end{description}

\end{itemize}

\end{fulllineitems}

\index{plot\_score() (data\_tools.models.Lasso method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{models:data_tools.models.Lasso.plot_score}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{plot\_score}}}{\emph{filename=None}, \emph{figsize=None}}{}
Plots the mean score across all folds obtained during CV.
The optimum C parameter chosen and its score are highlighted.
\begin{itemize}
\item {} \begin{description}
\item[{Arguments:}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{filename} {[}str{]}: Optional, \sphinxcode{\sphinxupquote{None}} by default. If
passed, indicates the file name or path where to store the
figure. Format must be specified (e.g.: .png, .pdf, etc)

\item {} 
\sphinxstyleemphasis{figsize} {[}tuple{]}: Optional, \sphinxcode{\sphinxupquote{None}} by default (default
matplotlib size). Any iterable containing two values
denoting the figure size (in inches) as {[}width, height{]}.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Returns:}] \leavevmode\begin{itemize}
\item {} 
{[}matplotlib.figure.Figure{]}: Figure object containing the
score plot.

\end{itemize}

\end{description}

\end{itemize}

\end{fulllineitems}


\end{fulllineitems}

\phantomsection\label{\detokenize{plots:module-data_tools.plots}}\index{data\_tools.plots (module)}

\section{data\_tools.plots}
\label{\detokenize{plots:data-tools-plots}}\label{\detokenize{plots::doc}}
Plotting functions module.
\index{density() (in module data\_tools.plots)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{plots:data_tools.plots.density}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{data\_tools.plots.}}\sphinxbfcode{\sphinxupquote{density}}}{\emph{df}, \emph{cvf=0.25}, \emph{sample\_col=False}, \emph{title=None}, \emph{filename=None}, \emph{figsize=None}}{}
Generates a density plot of the values on a data frame (row-wise).
\begin{itemize}
\item {} \begin{description}
\item[{Arguments:}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{df} {[}pandas.DataFrame{]}: Contains the values to generate the
plot. Each row is considered as an individual sample while
each column contains a measured value unless otherwise stated
by keyword argument \sphinxstyleemphasis{sample\_col}.

\item {} 
\sphinxstyleemphasis{cvf} {[}float{]}: Optional, \sphinxcode{\sphinxupquote{0.25}} by default. Co-variance
factor used in the gaussian kernel estimation. A higher value
increases the smoothness.

\item {} 
\sphinxstyleemphasis{sample\_col} {[}bool{]}: Optional, \sphinxcode{\sphinxupquote{False}} by default. Specifies
whether the samples are column-wise or not.

\item {} 
\sphinxstyleemphasis{title} {[}str{]}: Optional, \sphinxcode{\sphinxupquote{None}} by default. Defines the plot
title.

\item {} 
\sphinxstyleemphasis{filename} {[}str{]}: Optional, \sphinxcode{\sphinxupquote{None}} by default. If passed,
indicates the file name or path where to store the figure.
Format must be specified (e.g.: .png, .pdf, etc)

\item {} 
\sphinxstyleemphasis{figsize} {[}tuple{]}: Optional, \sphinxcode{\sphinxupquote{None}} by default (default
matplotlib size). Any iterable containing two values denoting
the figure size (in inches) as {[}width, height{]}.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Returns:}] \leavevmode\begin{itemize}
\item {} 
{[}\sphinxstyleemphasis{matplotlib.figure.Figure}{]}: the figure object containing the
density plot.

\end{itemize}

\end{description}

\end{itemize}

\end{fulllineitems}

\index{piano\_consensus() (in module data\_tools.plots)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{plots:data_tools.plots.piano_consensus}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{data\_tools.plots.}}\sphinxbfcode{\sphinxupquote{piano\_consensus}}}{\emph{df}, \emph{nchar=40}, \emph{boxes=True}, \emph{title=None}, \emph{filename=None}, \emph{figsize=None}}{}
Generates a GSEA consensus score plot like R package \sphinxcode{\sphinxupquote{piano}}’s
\sphinxcode{\sphinxupquote{consensusScores}} function, but prettier.
The main input is assumed to be a \sphinxcode{\sphinxupquote{pandas.DataFrame}} whose data
is the same as the \sphinxcode{\sphinxupquote{rankMat}} from the result of
\sphinxcode{\sphinxupquote{consensusScores}}.
\begin{itemize}
\item {} \begin{description}
\item[{Arguments:}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{df} {[}pandas.DataFrame{]}: Values contained correspond to the
scores of the gene-sets (consensus and each individual
methods). Index must contain the gene-set labels. Columns are
assumed to be \sphinxcode{\sphinxupquote{ConsRank}} (ignored), \sphinxcode{\sphinxupquote{ConsScore}} followed
by the individual methods (e.g.: \sphinxcode{\sphinxupquote{mean}}, \sphinxcode{\sphinxupquote{median}},
\sphinxcode{\sphinxupquote{sum}}, etc).

\item {} 
\sphinxstyleemphasis{nchar} {[}int{]}: Optional, \sphinxcode{\sphinxupquote{40}} by default. Number of string
characters of the gene-set labels of the plot.

\item {} 
\sphinxstyleemphasis{boxes} {[}bool{]}: Optional, \sphinxcode{\sphinxupquote{True}} by default. Determines
whether to show the boxplots of the gene-sets or not.

\item {} 
\sphinxstyleemphasis{title} {[}str{]}: Optional, \sphinxcode{\sphinxupquote{None}} by default. Defines the plot
title.

\item {} 
\sphinxstyleemphasis{filename} {[}str{]}: Optional, \sphinxcode{\sphinxupquote{None}} by default. If passed,
indicates the file name or path where to store the figure.
Format must be specified (e.g.: .png, .pdf, etc)

\item {} 
\sphinxstyleemphasis{figsize} {[}tuple{]}: Optional, \sphinxcode{\sphinxupquote{None}} by default (default
matplotlib size). Any iterable containing two values denoting
the figure size (in inches) as {[}width, height{]}.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Returns:}] \leavevmode\begin{itemize}
\item {} 
{[}\sphinxstyleemphasis{matplotlib.figure.Figure}{]}: the figure object containing a
combination of box and scatter plots of the gene-set scores.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Example:}] \leavevmode
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{piano\PYGZus{}consensus}\PYG{p}{(}\PYG{n}{df}\PYG{p}{,} \PYG{n}{figsize}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent{\hspace*{\fill}\sphinxincludegraphics[scale=0.6]{{piano_consensus_example}.png}\hspace*{\fill}}

\end{description}

\end{itemize}

\end{fulllineitems}

\index{venn() (in module data\_tools.plots)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{plots:data_tools.plots.venn}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{data\_tools.plots.}}\sphinxbfcode{\sphinxupquote{venn}}}{\emph{N, labels={[}'A', 'B', 'C', 'D', 'E'{]}, c={[}'C0', 'C1', 'C2', 'C3', 'C4'{]}, pct=False, title=None, filename=None, figsize=None}}{}
Plots a Venn diagram from a list of sets \sphinxstyleemphasis{N}. Number of sets must be
between 2 and 5 (inclusive).
\begin{itemize}
\item {} \begin{description}
\item[{Arguments:}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{N} {[}list{]}: Or any iterable type containing {[}set{]} objects.

\item {} 
\sphinxstyleemphasis{labels} {[}list{]}: Optional, \sphinxcode{\sphinxupquote{{[}'A', 'B', 'C', 'D', 'E'{]}}} by
default. Labels for the sets following the same order as
provided in \sphinxstyleemphasis{N}.

\item {} 
\sphinxstyleemphasis{c} {[}list{]}: Optional, \sphinxcode{\sphinxupquote{{[}'C0', 'C1' 'C2', 'C3', 'C4'{]}}} by
default (matplotlib default colors). Any iterable containing
color arguments tolerated by matplotlib (e.g.: \sphinxcode{\sphinxupquote{{[}'r', 'b'{]}}}
for red and blue). Must contain at least the same number of
elements as \sphinxstyleemphasis{N} (if more are provided, they will be ignored).

\item {} 
\sphinxstyleemphasis{pct} {[}bool{]}: Optional, \sphinxcode{\sphinxupquote{False}} by default. Indicates
whether to show percentages instead of absolute counts.

\item {} 
\sphinxstyleemphasis{title} {[}str{]}: Optional, \sphinxcode{\sphinxupquote{None}} by default. Defines the plot
title.

\item {} 
\sphinxstyleemphasis{filename} {[}str{]}: Optional, \sphinxcode{\sphinxupquote{None}} by default. If passed,
indicates the file name or path where to store the figure.
Format must be specified (e.g.: .png, .pdf, etc)

\item {} 
\sphinxstyleemphasis{figsize} {[}tuple{]}: Optional, \sphinxcode{\sphinxupquote{None}} by default (default
matplotlib size). Any iterable containing two values denoting
the figure size (in inches) as {[}width, height{]}.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Returns:}] \leavevmode\begin{itemize}
\item {} 
{[}\sphinxstyleemphasis{matplotlib.figure.Figure}{]}: the figure object containing a
combination of box and scatter plots of the gene-set scores.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Example:}] \leavevmode
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{N} \PYG{o}{=} \PYG{p}{[}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{\PYGZcb{}}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{} Sets A, B, C}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{venn}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent{\hspace*{\fill}\sphinxincludegraphics[scale=1.0]{{venn_example}.png}\hspace*{\fill}}

\end{description}

\end{itemize}

\end{fulllineitems}

\index{volcano() (in module data\_tools.plots)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{plots:data_tools.plots.volcano}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{data\_tools.plots.}}\sphinxbfcode{\sphinxupquote{volcano}}}{\emph{logfc}, \emph{logpval}, \emph{thr\_pval=0.05}, \emph{thr\_fc=2.0}, \emph{c=('C0'}, \emph{'C1')}, \emph{legend=True}, \emph{title=None}, \emph{filename=None}, \emph{figsize=None}}{}
Generates a volcano plot from the differential expression data
provided.
\begin{itemize}
\item {} \begin{description}
\item[{Arguments:}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{logfc} {[}list{]}: Or any iterable type. Contains the log
(usually base 2) fold-change values. Must have the same length
as \sphinxstyleemphasis{logpval}.

\item {} 
\sphinxstyleemphasis{logpval} {[}list{]}: Or any iterable type. Contains the -log
p-values (usually base 10). Must have the same length as
\sphinxstyleemphasis{logfc}.

\item {} 
\sphinxstyleemphasis{thr\_pval} {[}float{]}: Optional, \sphinxcode{\sphinxupquote{0.05}} by default. Specifies
the p-value (non log-transformed) threshold to consider a
measurement as significantly differentially expressed.

\item {} 
\sphinxstyleemphasis{thr\_fc} {[}float{]}: Optional, \sphinxcode{\sphinxupquote{2}}. by default. Specifies the
FC (non log-transformed) threshold to consider a measurement
as significantly differentially expressed.

\item {} 
\sphinxstyleemphasis{c} {[}tuple{]}: Optional, \sphinxcode{\sphinxupquote{('C0', 'C1')}} by default (matplotlib
default colors). Any iterable containing two color arguments
tolerated by matplotlib (e.g.: \sphinxcode{\sphinxupquote{{[}'r', 'b'{]}}} for red and
blue). First one is used for non-significant points, second
for the significant ones.

\item {} 
\sphinxstyleemphasis{legend} {[}bool{]}: Optional, \sphinxcode{\sphinxupquote{True}} by default. Indicates
whether to show the plot legend or not.

\item {} 
\sphinxstyleemphasis{title} {[}str{]}: Optional, \sphinxcode{\sphinxupquote{None}} by default. Defines the plot
title.

\item {} 
\sphinxstyleemphasis{filename} {[}str{]}: Optional, \sphinxcode{\sphinxupquote{None}} by default. If passed,
indicates the file name or path where to store the figure.
Format must be specified (e.g.: .png, .pdf, etc)

\item {} 
\sphinxstyleemphasis{figsize} {[}tuple{]}: Optional, \sphinxcode{\sphinxupquote{None}} by default (default
matplotlib size). Any iterable containing two values denoting
the figure size (in inches) as {[}width, height{]}.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Returns:}] \leavevmode\begin{itemize}
\item {} 
{[}matplotlib.figure.Figure{]}: Figure object containing the
volcano plot.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Example:}] \leavevmode
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{volcano}\PYG{p}{(}\PYG{n}{my\PYGZus{}log\PYGZus{}fc}\PYG{p}{,} \PYG{n}{my\PYGZus{}log\PYGZus{}pval}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent{\hspace*{\fill}\sphinxincludegraphics[scale=0.6]{{volcano_example}.png}\hspace*{\fill}}

\end{description}

\end{itemize}

\end{fulllineitems}

\phantomsection\label{\detokenize{strings:module-data_tools.strings}}\index{data\_tools.strings (module)}

\section{data\_tools.strings}
\label{\detokenize{strings:data-tools-strings}}\label{\detokenize{strings::doc}}
String operations module.
\index{is\_numeric() (in module data\_tools.strings)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{strings:data_tools.strings.is_numeric}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{data\_tools.strings.}}\sphinxbfcode{\sphinxupquote{is\_numeric}}}{\emph{s}}{}
Determines if a string can be considered a numeric value. NaN is
also considered, since it is float type.
\begin{itemize}
\item {} \begin{description}
\item[{Arguments:}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{s} {[}str{]}: String to be evaluated.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Returns:}] \leavevmode\begin{itemize}
\item {} 
{[}bool{]}: \sphinxcode{\sphinxupquote{True}}/\sphinxcode{\sphinxupquote{False}} depending if the condition is
satisfied.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Examples:}] \leavevmode
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{is\PYGZus{}numeric}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{True}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{is\PYGZus{}numeric}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}3.2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{True}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{is\PYGZus{}numeric}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{number}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{False}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{is\PYGZus{}numeric}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{NaN}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{True}
\end{sphinxVerbatim}

\end{description}

\end{itemize}

\end{fulllineitems}

\index{join\_str\_lists() (in module data\_tools.strings)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{strings:data_tools.strings.join_str_lists}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{data\_tools.strings.}}\sphinxbfcode{\sphinxupquote{join\_str\_lists}}}{\emph{a}, \emph{b}, \emph{sep=''}}{}
Joins element-wise two lists (or any 1D iterable) of strings with a
given separator (if provided). Length of the input lists must be
equal.
\begin{itemize}
\item {} \begin{description}
\item[{Arguments:}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{a} {[}list{]}: Contains the first elements {[}str{]} of the joint
strings.

\item {} 
\sphinxstyleemphasis{b} {[}list{]}: Contains the second elements {[}str{]} of the joint
strings.

\item {} 
\sphinxstyleemphasis{sep} {[}str{]}: Optional \sphinxcode{\sphinxupquote{'{'}}} (non separated) by default.
Determines the separator between the joint strings.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Returns:}] \leavevmode\begin{itemize}
\item {} 
{[}list{]}: List of the joint strings.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Example:}] \leavevmode
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{b} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{join\PYGZus{}str\PYGZus{}lists}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{sep}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZus{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{[\PYGZsq{}a\PYGZus{}1\PYGZsq{}, \PYGZsq{}b\PYGZus{}2\PYGZsq{}]}
\end{sphinxVerbatim}

\end{description}

\end{itemize}

\end{fulllineitems}



\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{d}
\item {\sphinxstyleindexentry{data\_tools.databases}}\sphinxstyleindexpageref{databases:\detokenize{module-data_tools.databases}}
\item {\sphinxstyleindexentry{data\_tools.diffusion}}\sphinxstyleindexpageref{diffusion:\detokenize{module-data_tools.diffusion}}
\item {\sphinxstyleindexentry{data\_tools.iterables}}\sphinxstyleindexpageref{iterables:\detokenize{module-data_tools.iterables}}
\item {\sphinxstyleindexentry{data\_tools.models}}\sphinxstyleindexpageref{models:\detokenize{module-data_tools.models}}
\item {\sphinxstyleindexentry{data\_tools.plots}}\sphinxstyleindexpageref{plots:\detokenize{module-data_tools.plots}}
\item {\sphinxstyleindexentry{data\_tools.strings}}\sphinxstyleindexpageref{strings:\detokenize{module-data_tools.strings}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}